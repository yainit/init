#   mailto: dmiosga6200<at>gmail.com  (C) 2008-2015, last changed: 2015-10-09 
# TODO: optimized (for unionfs) : 1. 
#                                 2. readonly files stay on disks if unused
#                                 3. one time kexec kernel reboot with hardwareoptimized precompiled kernel
#                                 4. writing import system changes required at next boot to
#                                   the same places where rootcopy directory locates from
#set -x

#echo   " Starting the $0  LIVE script......" #> /dev/console
PHASE=2
THIS="$0"
INITPREF="[ $PHASE$THIS ]:"
export PHASE PATH=.:/:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin:/usr/local/sbin   


[ "$DEBUG" != "" ] && export
debug_mark


header "starting Linux Live scripts, for a RAM based OS...."
header "for support contact the author: dmiosga6200<at>gmail.com " 
# check the root and boot devices and optimize for performance by
# adaptation to architecture and system parameters


[ "$KERNVER" = "" ] && kernvercheck

#if [ "`cat /proc/cmdline | grep "debug" 2>/dev/null`" != "" ]; then
[ "$INITDBG" != "" ] && check_kernel_config
#fi
  # install symlinks for busybox AFTER all the customized and optimized files are there!
  echoconsole  "$INITPREF" " Installing all symlinks for busybox....."    
  set_bbsymlinks "$INITPREF"
  /bin/busybox sync
  
  
  # switch any overwritten /bin/ash or /sbin/ash files back to /bin/busybox
  /bin/busybox rm -f  /bin/ash /sbin/ash /bin/sh /sbin/sh /usr/bin/ash /usr/sbin/ash /usr/bin/sh /usr/sbin/sh 2>/dev/null
  /bin/busybox ln -sf /bin/busybox /bin/ash    2>/dev/null
  /bin/busybox ln -sf /bin/ash     /bin/sh   2>/dev/null
  /bin/busybox sync

debug_mark

    echoconsole "$INITPREF" "  --> where to boot to: $ROOTDEV"
  
  inline_externalfile "archvarfile"
  
  # arch-functions are not mandatory, we might continue if none  
  if [ -e $ARCH-functions ]; then
    
   . $ARCH-functions
   # and optimize for cpu architecture
   #set -x
   set_cpuvars "$INITPREF"
   #  set +x
   # conditionally explode the compressed busybox and system files archive 
   /bin/busybox sync
   if [ "$NOAUTO" = "" ]; then
   
     reboot_optimized_kernel
     /bin/busybox sync
   
     RTFILES="$(/bin/busybox ls -1 rt.tar.* 2>/dev/null)"
     #  extract all compressed system files necessary for live boot if any....
     if [ "$RTFILES" != "" ]; then  
       # more than one: take only the first one
       #RTFILES="$(echo $RTFILES | /bin/busybox tr "\n" " " 2>/dev/null | /bin/busybox cut -f1 -d ' ' 2>/dev/null)"
       /bin/busybox cp -f /bin/busybox /bin/busybox_out  2>/dev/null
       echoconsole  "$INITPREF" " extracting the '$RTFILES' file with necessary binaries for further boot..."    
       # extract unconditionally
       /bin/busybox tar -xf "$RTFILES"  2>/dev/null
       if [ $? -ne 0 ]; then 
          echoconsole "$INITPREF" " error in preparing for further boot while extraction of '$RTFILES', reconfigure system!"
          debug_prompt "$INITPREF"
       else
          /bin/busybox sync
          #/bin/busybox sleep 1
          echoconsole "$INITPREF" ".... Done extraction of cpu-architecture appropriate files!"
          # clean up carefully
          /bin/busybox rm -f $RTFILES  2>/dev/null
       fi
       #set -x
       /bin/busybox sync
      fi
    
     # optimize if possible, from extracted or preinstalled executables
     if [ "$(/bin/busybox ls -1 /bin/busybox-*  2>/dev/null)" != "" ]; then
	cmdset_optimize   "$INITPREF" "/bin/busybox"    
	/bin/busybox sync
     else
	echoconsole "$INITPREF" " error in optimizing : choosable files, busybox-*  not found!"
     fi  
      
   fi # noauto
 
  fi # -e arch-functions

PHASE=3
INITPREF="[ $PHASE$THIS ]:"

debug_mark

  # clean up unused kernelmodules for too old kernelversions
  purge_unused_kernelmodules  "" "$INITPREF"
  /bin/busybox sync

debug_mark
  
  
  probe_for_kernelmodule_tarball
  /bin/busybox sync

debug_mark

  probe_for_kernelmodule_squashfs 
  /bin/busybox sync

debug_mark

  # clean up unused kernelmodules for too old kernelversions
  purge_unused_kernelmodules  "" "$INITPREF"
  /bin/busybox sync

#
debug_mark
  if [ "$NOMOD" = "" -a "$LOCAL_DRIVERS" != "" ]; then
     # kernelmodules need in some configurations the debugfs mounted to load
     # if no debugfs compiled in , it does not hurt
     if  `is_not_string_in_file  "debugfs"  "/proc/mounts" `; then 
       mount_debugfs
       /bin/busybox sync 2>/dev/null
     fi
     # the following only if explicitly specified by default or parameter
     if  [ "$DEVTMPFS" != "" ] ; then 
       mount_devtmpfs
       /bin/busybox sync 2>/dev/null
     fi
     if  [ "$DEVPTS" != "" ] ; then 
       mount_devpts
       /bin/busybox sync 2>/dev/null
     fi
     if  [ "$HUGETLBFS" != "" ] ; then 
       mount_hugetlbfs
       /bin/busybox sync 2>/dev/null
     fi
     if [ "$MODPROBE_FUNCTIONS_READ" = "" ]; then
       inline_external_file "modprobe-functions"
       /bin/busybox mdev -s  2>/dev/null
       /bin/busybox sync     2>/dev/null
     fi     
     
     check_for_depmod   
     # load modules if any resident in INITRAMFS
     if [ "$NOAUTO" != "" ]; then
       initial_modules_load_defaults
     else
       initial_modules_load_auto
     fi
     if [ "$NOSWAP" = "" ]; then 
       check_for_zramswap
     fi
    
  fi
  # check busybox before entering debug prompt
  if [ "$DEBUG" != "" -o "$INITDBG" != "" ]; then
    bbversion_check
    bbapplets_check
  fi
  
  if [ "$DEBUG" != "" -o "$INITDBG" != "" ]; then
    echoconsole  "$INITPREF" " init parameters: '$INITPARAMETERS' "
    echoconsole  "$INITPREF" " before branching out of init... "
    debug_prompt "$INITPREF"
  fi
  



PHASE=4
INITPREF="[ $PHASE$THIS ]:"


if ! check_filesystem "squashfs"; then
  echolog "your kernel $KERNVER has missing squashfs, you cannot load Live-Systems" 
  fatal "please reboot with another one or other initrd configuration !"
fi

echolog "Kernel version $KERNVER is so far valid for $OSNAME-$OSVER $MAXCMDSET $EXTENT , continuing boot...."

# only find and load the modules with squashfs appropriate to the kernel,
# marked by kernelversion in filename and extension according squashfs release
check_systemmodule_extension

#  check for necessary system modules with kerneldrivers in the initrd
mount_initrd_loops

debug_mark
# the squashfs has to be compiled into the kernel for a proper working linux-live!

# If there are other kernels then do the kexec-reboot with the 
# hardware optimized kernel

# make sure unionfs or aufs is loaded 
# if the modules are in initramfs from initrd and not compiled in kernel

if [ -d /lib/modules/$KERNVER/kernel ]; then
  if [ "`/bin/busybox cat /proc/filesystems | /bin/busybox grep 'unionfs' `" != "" ]; then
    modprobe_kernelmodule "unionfs"  
  elif [ "`/bin/busybox cat /proc/filesystems | /bin/busybox grep 'aufs' `" != "" ]; then
    modprobe_kernelmodule "aufs"  
  fi 
fi

#
debug_mark

if [ "$NOHOTPLUG" = "" ]; then
# start hotplugging before hw drivers load
  mdev_start_hotplug

fi

# note :  the root= parameter is checked at init,linuxrc
# if boot device was specified manually from prompt
# and we branched from  boot_device_dialog in liblinuxrc
# if it is empty dialog restarts
if [ "$(echo $ROOTDEV |  /bin/busybox tr -d [:digit:]  2>/dev/null) " != "/dev/ram" ]; then
   ROOTDEV="/dev/ram0"
fi

boot_device_check

/bin/busybox sync 

echolog "booting system to device '$ROOTDEV' is verified......"

debug_mark

/bin/busybox mount -o remount,rw /  2>/dev/null
# make sure ext3 and ext4 partitions are not mounted using ext2 driver,
# and vfat partitions are not mounted using msdos driver, allow xfs,f2fs, btrfs and reiserfs
echo -e "ext4\nf2fs\next3\next2\nvfat\nxfs\nntfs\nreiserfs\nbtrfs\n*" >/etc/filesystems

###############################################################################################
##   what is following now is the relict of ancient works from 2009 as forked from Slax
##   It needs urgently be worked over!!!!!!
#####################################################################################


/bin/busybox mkdir -p $UNION  #$EMSG
/bin/busybox mkdir -p $MEMORY #$EMSG

#   is the running kernel the ultimate solution in optimization?
if `is_substring_of "$EXTENT" " $KERNVER" ` && [ "$NOAUTO" = "" ]; then

 # save the initrd file we are booting from
 #if [ "$REMOVABLE" != "" -o "$NOUSB" = "" ]; then
 #   wait_for_external  "$WAITFORROOT"   
 #fi
 if [ "$INITCMD" != "" ]; then INITRD=$INITCMD; fi
  #  verify all blockdevices up
 if [ "$BOOTDEV" = "$ROOTDEV"  ]; then 
   #set_system_variables   
   find_in_computer   boot/$INITRD
   BOOTDEV=$(verify_device $DATADEV)
 else
   BOOTDEV=$(verify_device $BOOTDEV)
   #find_in_computer    boot/$INITRD
 fi
 BOOTINITRD=""
 BOOTKERN=""
 #set_system_variables   
 if [ "$BOOTDEV" != "" ]; then  
  if [ "$BOOTDEV" != "$DATADEV" ]; then
    find_file_on_dev "$BOOTDEV"   boot/$INITRD
    if [ $? = 0 ]; then 
      BOOTINITRD=$LIVEFULLPATH 
    fi
  else
    BOOTINITRD=/$MOUNTDIR/$(/bin/busybox basename $BOOTDEV)/boot/$INITRD
  fi
  if [ "$BOOTINITRD" = "" ]; then  
    echolog "ERROR: No path for boot initrd assigned. This should not happen"
  elif [ -e "$BOOTINITRD" ]; then
    /bin/busybox mkdir -p /boot  2>/dev/null
    /bin/busybox cp -f $BOOTINITRD   /boot/$INITRD  2>/dev/null
    BOOTKERN="$(echo $KERNVER | /bin/busybox cut -f1 -d- 2>/dev/null)"
    BOOTKERN=`/bin/busybox find /$(/bin/busybox dirname $BOOTINITRD) -name   "vmlinuz-$BOOTKERN-$EXTENT"`
    if [ "$BOOTKERN" != "" ]; then
      /bin/busybox cp -f $BOOTKERN    /boot/  2>/dev/null
    else
      echolog "No kernel of type $(echo $KERNVER | /bin/busybox cut -f1 -d- 2>/dev/null)-$EXTENT found"
    fi
  else
     echolog " No initrd found in TARGETROOT/boot/$INITRD for reboot with other kernel !"
  fi
 else
   #if [ "$DATADEV" = "" ]; then
    echolog " No boot/$INITRD  found in $BOOTDEV , retrying to find it in computer...."
    find_in_computer   boot/$INITRD
    BOOTDEV=$(verify_device $DATADEV)
    BOOTINITRD=$LIVEFULLPATH
    if [ ! -e "$BOOTINITRD" ]; then 
       BOOTINITRD=/$MOUNTDIR/$(/bin/busybox basename $DATADEV)/boot/$INITRD
    fi
    if [ -e "$BOOTINITRD" ]; then
       /bin/busybox mkdir -p /boot  2>/dev/null
       /bin/busybox cp -f $BOOTINITRD   /boot/$INITRD  2>/dev/null
       BOOTKERN="$(echo $KERNVER | /bin/busybox cut -f1 -d- 2>/dev/null)"
       BOOTKERN=`/bin/busybox find /$(/bin/busybox dirname $BOOTINITRD) -name "vmlinuz-$BOOTKERN-$EXTENT"`
       if [ "$BOOTKERN" != "" ]; then
        /bin/busybox cp -f $BOOTKERN    /boot/  2>/dev/null
       else
        echolog "No kernel of type $(echo $KERNVER | /bin/busybox cut -f1 -d- 2>/dev/null)-$EXTENT found"
       fi
    else
       echolog " No initrd found for reboot with other kernel !"
    fi
   #fi 
 fi
 # No use of kexec as long it is not 
 # compilable as static and position independent! D.Miosga, 2014
 # for now the option --reuseinitrd   does not work on all architectures
 # this is the safe method
 #if [ -e /boot/$INITRD ]; then
 #   reboot_hardware_optimized ""
 #else
 #   echolog " No initrd $INITRD found in bootpath $MOUNTDIR/$(/bin/busybox basename $BOOTDEV)/boot for reboot with other kernel !"
 #   echolog " continuing with vmlinuz-$KERNVER ......."
 #fi
#else
#    echolog " confirming kernel $KERNVER is no more optimizable for $EXTENT, continuing......."
fi



debug_mark

# Find livecd data directory by searching for livecd.sgn file
echolog "looking for '$LIVEDIRNAME' data directory (searching for file: $SGNFILE )"

# First, try from= boot argument, if given
#DATAFROM=$(cmdline_value from)
DATAFROM=$FROM


debug_mark


if [ "$DATA" = "" ]; then
# if I develop b/ash scripting, I am thinking as a stupid b/ash developer in his world
# not as a kernel developer who knows the next 5 years.
# Therefore, maybe this is enough:
# echo /bin/mdev >/proc/sys/kernel/hotplug
 if [ "$REMOVABLE" != "" -o "$NOUSB" = "" ]; then
    wait_for_external  "$WAITFORROOT"   
 fi
 set_system_variables
 find_in_computer $LIVEDIRNAME/$SGNFILE
 DATA=$(/bin/busybox dirname $LIVEFULLPATH 2>/dev/null)
 if [ "$DATA" = "" ]; then
    echolog  "$LIVEDIRNAME/$SGNFILE not found in this machine, retrying..."
    if [ "$REMOVABLE" != "" -o "$NOUSB" = "" ]; then
       wait_for_external  "$WAITFORROOT"   
       echolog  "...removable devices awaited to come up!"
    fi
    #set_system_variables
    find_in_computer $LIVEDIRNAME/$SGNFILE
    DATA=$(/bin/busybox dirname $LIVEFULLPATH 2>/dev/null)
 fi
fi

if [ ! -e $DATA/$SGNFILE ]; then
    echolog " Signature File $SGNFILE not found, last retry....."
    if [ "$REMOVABLE" != "" -o "$NOUSB" = "" ]; then
     wait_for_external "5"
     echolog  "...removable devices awaited to come up!"
    fi
    #find_file_on_dev $LIVEDIRNAME/$SGNFILE
    find_in_computer $LIVEDIRNAME/$SGNFILE
    DATA=$(/bin/busybox dirname $LIVEFULLPATH 2>/dev/null)
fi

if [ "$DATA" = "" ]; then 
   fatal \
   "$LIVEDIRNAME data not found. $OSNAME is booting from S/ATA hard and optical disks and USB-Flashdrives.  You are maybe using an unsupported boot device (eg. SCSI or old PCMCIA). Workaround: Copy the directory $LIVEDIRNAME from your system media to a local or removable IDE/SATA disk drive (or USB-FlashMemory-Stick), eg. to /mnt/sda1/$LIVEDIRNAME or C:\\$LIVEDIRNAME   or specify e.g. root=/dev/sda1 to boot from installed system on hard disk  - Then try to boot again with appropriate kernel selection from bootmenu."
fi

echolog "....using $LIVEDIRNAME data from $DATA/$SGNFILE "

debug_mark


echolog "setting up directory for changes"
#CHANGESVAL=$(cmdline_value changes)
#CHANGESVAL=$CHANGES
if [ "$CHANGES" != "" ]; then
   #find_file_on_dev $CHANGES
   find_in_computer $CHANGES
   CHANGESMNT=$LIVEFULLPATH
   echolog "directory for changes found at $CHANGESMNT"
fi


if [ "$CHANGESMNT" != "" ]; then
   mount_device "$CHANGESMNT" $MEMORY # removes $MEMORY if CHANGESMNT is wrong
fi
# test if the filesystem is writable so changes can be stored to it
if [ "$RAMSIZE" = "" ]; then 
   RAMSIZE=$INITIALRAM 
fi    

/bin/busybox touch $MEMORY/empty 2>/dev/null && \
/bin/busybox rm -f $MEMORY/empty 2>/dev/null
# if changes can't be mounted or the filesystem is not writable,
# fallback to the default: tmpfs
if [ $? -ne 0 ]; then
{ 
   echolog "changes not used or not writable, using memory only"
   fumount $MEMORY
   /bin/busybox mkdir -p $MEMORY #$EMSG  # mount_device might removed it
#   RAMSIZE=$(cmdline_value ramsize)

   /bin/busybox mount -t tmpfs -o "size=$RAMSIZE" tmpfs $MEMORY 
   XINO=$MEMORY  
}
else
{
   # So it is writable, we will keep the filesystem mounted.
   # Check if it supports links and chmod.
   # If not, overmount CHANGES using posixovl
   echolog "testing the filesystem for posix compatibility"
   /bin/busybox touch $MEMORY/.empty1 && \
   /bin/busybox ln -sf $MEMORY/.empty1 $MEMORY/.empty2 2>/dev/null && \
   /bin/busybox chmod +x $MEMORY/.empty1 2>/dev/null  && \
   test -x $MEMORY/.empty1 && \
   /bin/busybox chmod -x $MEMORY/.empty1 2>/dev/null  && \
   test ! -x $MEMORY/.empty1 && \
   /bin/busybox rm $MEMORY/.empty1 $MEMORY/.empty2 2>/dev/null
   if [ $? -ne 0 ]; then
      echolog "not compatible - starting posixovl"
      /bin/busybox rm $MEMORY/.empty1 $MEMORY/.empty2 2>/dev/null
      /bin/busybox mkdir -p $CHANGES
      posixovl -F $CHANGES -- -o attr_timeout=300,entry_timeout=300,negative_timeout=300,kernel_cache,allow_other
      /bin/busybox find $CHANGES >/dev/null 2>&1 # cache everything now
   fi
}
fi

debug_mark

# $UNION will be used as a root directory, livecd modules will be added soon
echolog "setting up support for union-/layer-filesystem  (here:  aufs or unionfs)......."
/bin/busybox mount -o remount,rw  /  2>/dev/null
if [ "$CHANGES" != "" ]; then 
  /bin/busybox mkdir -p $CHANGES  2>/dev/null
fi

if [ "$IMAGES" != "" ]; then 
  /bin/busybox mkdir -p $IMAGES  2>/dev/null #$EMSG
fi


# store the xino file in memory in all cases, it's faster and safer
if [ "$XINO" != "$MEMORY" ]; then
   /bin/busybox mkdir -p $XINO
   /bin/busybox mount -n -t tmpfs tmpfs $XINO
fi

debug_mark

# cascading check through layerfilesystems
check_filesystem "unionfs"
if [ $? -ne 0 ]; then
{
  check_filesystem "aufs"
  if [ $? -ne 0 ]; then
  {
    check_filesystem "aufs25"
    if [ $? -eq 0 ]; then 
      LAYERFS="aufs25"
    else
      fatal "your kernel configuration is missing the union-/layer-filesystem $LAYERFS , reconfigure !"
    fi
  }
  else
    LAYERFS="aufs"
  fi
}
else
  LAYERFS="unionfs"
fi

if [ "$LAYERFS" = "aufs" ];  then
{
   MNTDIR=aufs
   /bin/busybox mount -t $LAYERFS -o nowarn_perm,xino=$XINO/.aufs.xino,br:$CHANGES=rw $MNTDIR $UNION 2>/dev/null
   if [ $? -ne 0 ]; then
   {
    /bin/busybox dmesg | /bin/busybox tail -n 1 
    echolog " mount error at mountpoint $UNION on filesystem $LAYERFS :"
    echolog " retrying with another module ...aufs25... "
    LAYERFS="aufs25"
   }
   else
        echolog " union-/layer-filesystem aufs successfully mounted at $UNION"
   fi
}
fi


if [ "$LAYERFS" = "aufs25" ];  then
{
    MNTDIR=aufs25
    /bin/busybox mount -t aufs25 -o nowarn_perm,xino=$XINO/.aufs.xino,br:$CHANGES=rw $MNTDIR $UNION 2>/dev/null
     if [ $? -ne 0 ]; then
     {
       echolog " can't setup aufs25 as union filesystem, continuing, trying another possibility ..... "
       /bin/busybox mount -t aufs25 -o nowarn_perm,xino=$XINO/.aufs25.xino,br:$CHANGES=rw aufs25 $UNION
       if [ $? -ne 0 ]; then 
          LAYERFS="unionfs"
          echolog " can't setup aufs or aufs25 as union filesystem, continuing with unionfs ..... "
       else 
          echolog " union-/layer-filesystem aufs25 successfully mounted at $UNION"
       fi 
     }
     else
        echolog " union-/layer-filesystem aufs25 successfully mounted at $UNION"
     fi
}
fi

if [ "$LAYERFS" = "unionfs" ];  then
{
#  it is sufficient to make the filesystem writeable and usable
#  the check for existency of unionfs was given in kernvercheck() in liblinuxlive
    MNTDIR=unionfs
    /bin/busybox mount -o rw,remount  /  2>/dev/null
    if [ $? -ne 0 ]; then
    {
      /bin/busybox dmesg | /bin/busybox tail -n 1 
      echolog " mount error at mountpoint / on filesystem $LAYERFS :"
      /bin/busybox mount -t $LAYERFS  $MNTDIR $UNION
      if [ $? -ne 0 ]; then
      {
        /bin/busybox dmesg | /bin/busybox tail -n 1 
        echolog " mount error at mountpoint $MNTDIR on filesystem $LAYERFS !"
        echolog " can't mount unionfs as union-/layer-filesystem or it is mounted already, see: "
        /bin/busybox mount
        /bin/busybox cat /proc/filesystems  
        fatal " neither aufs nor unionfs is to setup as a unionfs !"
      }
      else 
        echolog " unionfs is set up as the union-/layer-filesystem.... "
      fi  
    }
    else
       echolog " unionfs is set up as the union-/layer-filesystem.... "
    fi 
}
fi 

debug_mark


if [ "$CP2RAM" = "copy2ram" ]; then
{
   /bin/busybox mkdir -p $COPY2RAM
   # make sure it's in RAM even with changes= parameter
   if [ "$CHANGESMNT" != "" ]; then
   { 
      /bin/busybox mount -t tmpfs -o rw,"size=$RAMSIZE" tmpfs $COPY2RAM
      if [ $? -ne 0 ]; then
         echolog  " not successfully mounted tmpfs at $COPY2RAM !!  "
      else
         echolog  " mounted tmpfs at directory $COPY2RAM ...  "
      fi
   }   
   fi
   echolog "copying $LIVEDIRNAME data to RAM, this may take some time..."
   copy_to_ram $DATA $COPY2RAM
   cd_autoeject 1
   fumount $DATA
   fumount $MOUNTDIR/*
   /bin/busybox rmdir   $MOUNTDIR/*  2>/dev/null # mounted device names are empty, remove them
   DATA=$COPY2RAM
   cd_autoeject 0
}
fi 

debug_mark

/bin/busybox mount -o rw,remount / 2>/dev/null
echolog " creating necessary directories at target-tree $UNION......"
create_directory_tree "$UNION"

/bin/busybox chmod -fR 1744 $UNION      2>/dev/null
/bin/busybox chmod     1777 $UNION/tmp  2>/dev/null

verify_all_kernelmodules "$DATA/optional" "$UNION"

debug_mark

# DATA contains path to the base directory of all fs modules which need
# to be mounted and inserted into live filesystem. Do it now.
echolog "inserting all modules form $DATA/base and creating live filesystem........"

/bin/busybox mount -o rw,remount / 2>/dev/null
#mkdir -p $union/etc  2>/dev/null
union_insert_modules $UNION $DATA $IMAGES

# the $MEMORY directory can contain $MEMORY/modules too
# in the case if changes= boot argument is used. If not, it doesn't hurt
echolog "inserting further modules into live filesystem.........."
#if [ "$LAYERFS" = "unionfs" ]; then  mount -o rw,remount / ; fi 
/bin/busybox mount -o rw,remount / 2>/dev/null
union_insert_modules $UNION $MEMORY $IMAGES
#cp  $IMAGES/base/linuxrc-local  $UNION/etc   2>/dev/null
# finally make sure that all kernelmodules on the system machine are 
# accessible for the booted kernel


debug_mark

echolog "copying content of rootcopy directory"

/bin/busybox mount -o rw,remount /   2>/dev/null
# copy with forced overwrite and file attribute preservation
/bin/busybox cp -dpRf $DATA/rootcopy/*  $UNION   2>/dev/null
if [ $? -ne 0 ]; then  
  echolog " rootcopy failed , is directory empty? "
fi

# TODO: if copy2ram is used, how many place is to preserve the originals in memory, how many
#  of it can be resident in RAM uncompressed and how much has to be cleaned up without deleting the originals !
echolog "copying mandatory files from initramfs to new root union directory"
/bin/busybox cp -f /liblinuxrc   $UNION/usr/lib  $EMSG
/bin/busybox cp -f /liblinuxrc   $UNION/usr/lib/liblinuxlive  $EMSG
/bin/busybox cp -f /liblinuxrc   $UNION/etc/rc.d  $EMSG
/bin/busybox cp -f /liblinuxrc   $UNION/bin  $EMSG
/bin/busybox cp -f /liblinuxrc   $UNION/bin/liblinuxlive  $EMSG
/bin/busybox cp -f /linuxrc      $UNION/etc  $EMSG
/bin/busybox cp -f /linuxrc-live $UNION/etc  $EMSG
/bin/busybox cp -f /linuxrc      $UNION/usr/lib  $EMSG
/bin/busybox cp -f /linuxrc-live $UNION/usr/lib  $EMSG
/bin/busybox cp -f $DATA/base/linuxrc-local  $UNION/etc   $EMSG 
#if [ "$(ls -1  $UNION/bin/busybox)" = "" ]; then 
/bin/busybox cp -f   /bin/busybox      $UNION/bin     $EMSG
/bin/busybox cp -f   /bin/busybox      $UNION/usr/bin     $EMSG
cd $UNION/usr/bin
./busybox --install -s  $EMSG
cd /
/bin/busybox cp -fP   /lib/*        $UNION/lib     $EMSG
/bin/busybox cp -fR  /opt/*        $UNION/opt    $EMSG
/bin/busybox cp -fR  /usr/*        $UNION/usr    $EMSG
#fi
#if [ "$(ls -1  $UNION/bin/busybox)" = "" ]; then 
#cp -f /bin/busybox   $UNION/usr/bin $EMSG
#fi



debug_mark

echolog " verifying $UNION/etc/fstab and remove unnecessary  /mnt directories....."
if [ "$LAYERFS" = "unionfs" ]; then  
   /bin/busybox mount -o rw,remount / 
fi 

/bin/busybox touch $UNION/etc/fstab  2>/dev/null
#rmdir $UNION/mnt/*      2>/dev/null
#if [ "$LAYERFS" = "unionfs" ]; then  mount -o rw,remount / ; fi 
/bin/busybox mount -o rw,remount /   2>/dev/null
#if [ "$KERNVER" = "$DEFKERNVER" ]; then cpuid_optimize; fi  
echolog " updating  $UNION/etc/fstab ......"
fstab_update $UNION
# everything is ready now, so we may unload unused kernel modules
# and do some cleanup, unmount few things which are no longer needed.
#rmmod_unused_modules

if [ "$LAYERFS" != "unionfs" ]; then 
  fumount /usr
  fumount /sys
fi


# unmount the loop devices with squashfs
if [ "$LAYERFS" = "unionfs" ]; then 
  echolog " unmounting unused loop-devices......"
  /bin/busybox umount /dev/loop*  2>/dev/null
  if [ $? -ne 0 ]; then
    if [ $DEBUG_IS_ENABLED ]; then
      echolog "...failure in unmounting loop-devices!"
      blkid
      /bin/busybox mount
    fi
  fi
fi

#if [ "$LAYERFS" = "unionfs" ]; then  
#   mount -o rw,remount / 
#fi 

echolog " unionfilesystem '$LAYERFS' in directory /$UNION is set up for switch_root...."
# Boot will contain whatever was in ./boot directory in the bootable media
# Error output goes to null, as nothing is mounted with copy2ram
if [ "$LAYERFS" != "unionfs" ]; then
  if [ "$MOUNTMODE" = "rw" ];
    /bin/busybox cp  /var/log/livedbg   $UNION/var/log/livebootlog     2>/dev/null
    /bin/busybox cp  /init.log        $UNION/var/log/initbootlog    2>/dev/null  
  fi
  /bin/busybox mount -n -o rbind $(/bin/busybox dirname $DATA)/boot  $UNION/boot  2>/dev/null
fi

debug_mark

# Union contains all the files and directories unioned from all modules.
# Change root directory to it, and move initrd's root to /mnt/live/initramdisk
# Finaly execute /sbin/init to start the distribution.
echolog "changing root directory..."
if [ "$LAYERFS" = "unionfs" ]; then  
  RESTARTMDEV=""
  /bin/busybox mount  -o rw,remount /  2>/dev/null 
# save the logging
#  cp  /var/log/livedbg $UNION/var/log/livebootlog $EMSG
#  cp -a /etc/rc.d/*  $UNION/etc/rc.d
  /bin/busybox cp -RP /dev  $UNION    2>/dev/null 
  if [ $? -ne 0 ]; then
     RESTARTMDEV=1
  fi
    
   if [ ! -e /etc/fstab ]; then 
      if [ ! -e $UNION/etc/fstab ]; then 
         echolog " error in creating $UNION/etc/fstab, retrying.... "
         fstab_update   $UNION
      fi
      /bin/busybox cp  $UNION/etc/fstab etc/fstab
   else
      fstab_update   $UNION
   fi
  # save the logging
  /bin/busybox cp  /var/log/livedbg $UNION/var/log/livebootlog $EMSG
  /bin/busybox cp  /init.log   $UNION/var/log/initbootlog   $EMSG

  fumount $DATA
  fumount $MOUNTDIR/*
  fumount /usr
  fumount /sys
fi

# If a boot parameter nohotplug is used, copy all dev files (found by mdev)
# to the unioned dev directory, your Linux may need them since most likely
# udev will not be started in that case
#if [ "$(cmdline_parameter nohotplug)" != "" ]; then
if [ "$NOHOTPLUG" != "" -a "$LAYERFS" = "aufs" ]; then
   /bin/busybox cp -PR /dev $UNION  2>/dev/null
fi

cd  $UNION
/bin/busybox sync
# make sure some devices are there
if [ ! -e /$UNION/dev/console ]; then 
   /bin/busybox mknod /$UNION/dev/console c 5 1
fi

if [ ! -e /dev/initctl ]; then 
   /bin/busybox mknod -m 0744 /dev/initctl c 5 1
fi

if [ ! -e /$UNION/dev/initctl ]; then 
   /bin/busybox mknod -m 0744 /$UNION/dev/initctl c 5 1
fi


if [ ! -e /$UNION/dev/null ]; then 
   /bin/busybox mknod /$UNION/dev/null c 1 3
fi


cd /$UNION/bin
if [ ! -e /$UNION/bin/bash -a -e /$UNION/bin/busybox ]; then
   /bin/busybox ln -sf "./busybox" "sh"
   /bin/busybox ln -sf "./busybox" "ash"
elif [ ! -e /$UNION/bin/ash -a -e /$UNION/bin/bash ]; then
   #/bin/busybox ln -sf "./bash" "ash"
   /bin/busybox ln -sf "./bash" "sh"
else
   /bin/busybox ln -sf "./bash" "sh"
   /bin/busybox ln -sf "./busybox" "ash"
fi
cd ..
# TODO: Do more preliminary checks for whether to use chroot or switch_root

# find chroot and init
CHROOTBB=""
if [ -e /bin/busybox ];       then  
     CHROOTBB="/bin/busybox chroot"
fi

if [ "$CHROOT" = "" ]; then
# assign preferrably files in the target system
  if [ -x /$UNION/bin/chroot ];      then  CHROOT="/$UNION/bin/chroot";      fi
  if [ "$CHROOT" = "" ]; then
    if [ -x /$UNION/sbin/chroot ];     then  CHROOT="/$UNION/sbin/chroot";     fi
  fi
  if [ "$CHROOT" = "" ]; then
    if [ -x /$UNION/usr/bin/chroot ];  then  CHROOT="/$UNION/usr/bin/chroot";  fi
  fi
  if [ "$CHROOT" = "" ]; then
    if [ -x /$UNION/usr/sbin/chroot ]; then  CHROOT="/$UNION/usr/sbin/chroot"; fi
  fi
  if [ "$CHROOT" = "" ]; then 
    echolog "Can't find executable chroot command, trying to boot with installed busybox...."
    if [ "$(/bin/busybox ls -1 /$UNION/bin/busybox)" != "" ]; then 
       cd bin
       /bin/busybox ln -sf "/$UNION/busybox" "chroot" 
       CHROOT="/$UNION/bin/chroot"
       cd ..
    fi
    if [ ! -e $CHROOT ]; then 
      fatal " cannot find any executable chroot command!"
    fi 
  fi

fi

if [ "$INIT" = "" ]; then

  if [ -x ./bin/init ];  then INIT="./bin/init";  fi
  if [ "$INIT" = "" ]; then
    if [ -x ./sbin/init ]; then INIT="./sbin/init"; fi
  fi
  
  if [ "$INIT" = "" ]; then 
    echolog "Can't find executable chroot command, trying to boot with installed busybox...."
    if [ "$(/bin/busybox ls -1 bin/busybox)" != "" ]; then 
       cd bin
       /bin/busybox ln -sf "./busybox" "init" 
       INIT="/bin/init"
       cd  ..
    else
       fatal "Can't find executable init command in boot target system!"
    fi 
  fi

fi

INITBB=""
if [ -e /bin/busybox ];       then  
 cd /bin
 /bin/busybox ln -sf "busybox" "init" 
 cd /$UNION
 INITBB="/bin/init"
else
 INITBB="/bin/busybox init"
fi

echolog " switching to new rootfilesystem with unionfilesystem '$LAYERFS' and internal directory named  $UNION "

# time to end Linux Live scripts and start the distribution itself,
# using /sbin/init or whatever was found.
header " end of boot scripts, starting $LIVEDIRNAME "

debug_mark

if [ "$LAYERFS" != "unionfs" ]; then
{
  /bin/busybox mount -n -o remount,$MOUNTMODE  $MNTDIR  .  

  if [ $? -ne 0 ]; then 
    echolog " cannot mount $LAYERFS to  $(pwd)/$MNTDIR "
    fatal " not mounted the filesystem ' $LAYERFS ' to the directory $(pwd)/$MNTDIR can't continue "
  fi
# We will copy init from the distro to initrd (there should be 2MB free)
# This allows us to use the cleanup script during reboot, as init will be
# started from memory and not from the union and /union will not be busy.
  # save the logging
   if [ "$MOUNTMODE" = "rw" ]; then
  /bin/busybox cp  /var/log/livedbg $UNION/var/log/livebootlog1 $EMSG
  /bin/busybox cp  /init.log  $UNION/var/log/initbootlog  $EMSG
  fi
   /bin/busybox cp -af $INIT /bin
   if [ $? -eq 0 ]; then
   {
     echolog " sucessfully copied $INIT to /bin/ "
     #pivot_root . $INITRAMDISK
     if [ $? -eq 0 ]; then 
       /bin/busybox sync
       exec $CHROOT  ./  $INITRAMDISK/bin/init <dev/console >dev/console 2>&1
     fi
   }
   else # If copying fails, start init directly.
   {
      echolog " something went wrong with copying  `pwd`/$INIT to ./bin  "
      echolog " starting init directly...... "
      #pivot_root . $INITRAMDISK
      /bin/busybox sync
      exec $CHROOT ./ $INIT <dev/console >dev/console 2>&1
   }
   fi
   /bin/busybox sync
   exec $CHROOT ./ $INIT <dev/console >dev/console 2>&1
   header " !!ERROR!! "
   fatal  "You are not supposed to arrive at this program step here, something went wrong! Check your init-, linuxrc- and liblinuxrc-scripts and your kernel!"
}
else
{

  echolog "last preparations..."
  if [ "$DEBUG_IS_ENABLED" != "" ]; then set -x ; fi
  /bin/busybox mount -n -o rw,remount /  2>/dev/null
  cd /
  cd $UNION

#  mount  -o rw,remount /  #2>/dev/null
  #if [ "$RESTARTMDEV" = "1" ]; then 
  #  bin/busybox echo  " recreating /dev files with 'mdev -s'......."
  #  bin/busybox mdev -s 
  #fi
# execute optional local shell script for switching root preparation
  if  [ -e  etc/linuxrc-local ]; then 
    #exec  etc/linuxrc-local  2>/dev/null
    .  etc/linuxrc-local
  fi
  echolog "now switching...."

  debug_mark 

   if [ "$MOUNTMODE" = "rw" ]; then
    /bin/busybox cp -f /var/log/livedbg var/log/livebootlog3 $EMSG
    /bin/busybox cp -f /init.log     var/log/initbootlog  $EMSG
   fi 
   /bin/busybox sync
  #exec $CHROOT ./ $INIT $RUNLEVEL <dev/console >dev/console 2>&1
  exec $CHROOTBB ./ $INIT $RUNLEVEL <dev/console >dev/console 2>&1
  #if [ $? -ne 0 ]; then 
    echolog " failed to change root, retrying....."
   if [ "$MOUNTMODE" = "rw" ]; then
    /bin/busybox cp -f /var/log/livedbg var/log/livebootlog3 $EMSG
    /bin/busybox cp -f /init.log     var/log/initbootlog  $EMSG
   fi 
    /bin/busybox sync
#    exec $CHROOT  ./  $INIT  $RUNLEVEL  2>/dev/null
    exec $CHROOTBB  ./  "$INITBB"  $RUNLEVEL  <dev/console >dev/console 2>&1
    
   # if [ $? -ne 0 ]; then 
      echolog " failed to change root, last trial without init:"
   if [ "$MOUNTMODE" = "rw" ]; then
    /bin/busybox cp -f /var/log/livedbg var/log/livebootlog3 $EMSG
    /bin/busybox cp -f /init.log     var/log/initbootlog  $EMSG
   fi 
  header "!!ERROR!!"
  fatal  "You are not supposed to arrive at this program step here, something went wrong! Check your init-, linuxrc- and liblinuxrc-scripts and your kernel!"

}
fi 

