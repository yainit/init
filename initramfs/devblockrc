#
# /devblockrc:  init script to switch rootfs from an initramfs and boot
#            installed system
#            This requires that your kernel supports initramfs!!!
#   (c) Dieter Miosga 2009-06-01 through 2016-01-05
PHASE=4

INITPREF="[ $PHASE$THIS ]"

echogreen "$INITPREF" " starting '$THIS' init script "
echobold  "$INITPREF" " for support contact the author mailto:dmiosga6200<at>gmail.com "

inline_external_file "yainitdefaults"
if [ "$ROOTDIR" = "" ]; then 
  ROOTDIR=$DEFAULT_ROOTDIR
fi
/bin/busybox mkdir -p $ROOTDIR 

export PATH=$PATH:$ROOTDIR/bin:$ROOTDIR/sbin:$ROOTDIR/usr/bin:$ROOTDIR/usr/sbin

[ "$INITDBG" != "" ] && export
debug_mark

#check_kernel_config

if [ "$KERNVER" = "" ]; then 
  set_kernver
  assign_kernver_vars
fi
# temporarily for testing purposes
start_tracing
#
# in case of unrecognized cmdline informations
inline_external_file "initsys-functions"
#read_cmdline
#debug_mark
#assign_init_variables
#debug_mark
#parse_rootdevice_string
#debug_mark
#echoconsole "$INITPREF" "Reading the Blockdevice Functions ...."
#inline_external_file "blockdevice-functions"
#echoconsole "$INITPREF" "Recognizing rootfilesystem device"
#recognize_rootdevice
#debug_mark

if [ "$ROOT" = "" ]; then
  read_cmdline
  assign_init_variables
  debug_mark
  parse_rootdevice_string
fi
#
if [ "$ROOTDEV" = "" ]; then  
  parse_rootdevice_string
  debug_mark
fi
echoconsole "$INITPREF" "Reading the Blockdevice Functions ...."
inline_external_file "blockdevice-functions"
echoconsole "$INITPREF" "Recognizing rootfilesystem device"
recognize_rootdevice
#
/bin/busybox mdev -s 2>/dev/null 
/bin/busybox usleep 500000 2>/dev/null 
/bin/busybox sync  2>/dev/null   
#
debug_mark
ROOTDEVOLD="$ROOTDEV"
#
if [ "$ROOTDEV" = "" ]; then  
  read_cmdline
  assign_init_variables
  parse_rootdevice_string
  debug_mark
  echoconsole "$INITPREF" "Reading the Blockdevice Functions ...."
  inline_external_file "blockdevice-functions"
  echoconsole "$INITPREF" "Recognizing rootfilesystem device"
  recognize_rootdevice
  /bin/busybox mdev -s 2>/dev/null 
  /bin/busybox usleep 500000 2>/dev/null 
  /bin/busybox sync  2>/dev/null   
fi
#
debug_mark
#
if [ -e "$ROOTDEV" ] && `is_accessible_blockdevice "$ROOTDEV"`; then
  echoconsole "$INITPREF" " Recognized rootfilesystem device: '$ROOTDEV'"
elif [  "$ROOTDEV" != "" ]; then
  #echoconsole "$INITPREF"  " Reading the Blockdevice Functions ...."
  #inline_external_file "blockdevice-functions"
  echoconsole "$INITPREF"  " Recognizing rootfilesystem device"
  recognize_rootdevice
  /bin/busybox mdev -s 2>/dev/null 
  /bin/busybox usleep 500000 2>/dev/null 
  /bin/busybox sync  2>/dev/null 
  #
  # if the root device is specified but still unrecognized
  if [ "$ROOTDEV" = "$ROOTDEVOLD" -o "$ROOTDEV" = ""  ]; then
    echoconsole "$INITPREF" "Rootfilesystem device not correctly detected!"
    echoconsole "$INITPREF" "Rereading and waiting for it to come up...."
    read_cmdline
    assign_init_variables
    parse_rootdevice_string
    inline_external_file "blockdevice-functions"
    set_disk_parameters
    recognize_rootdevice
    /bin/busybox mdev -s 2>/dev/null 
    /bin/busybox usleep 500000 2>/dev/null 
    /bin/busybox sync  2>/dev/null   
  fi
  # the loop during await rootdevice to come up
  debug_mark
  if [  0$MAXCYCLES -lt 10 ]; then
    MAXCYCLES=5
  fi
  i=0
  while [ 0$i -le 0$MAXCYCLES ] ; do 
    if  `is_not_up_rootdevice`; then
      /bin/busybox mdev -s 2>/dev/null 
      /bin/busybox usleep 500000 2>/dev/null 
      /bin/busybox sync  2>/dev/null 
      recognize_rootdevice
    else 
      break
    fi
    i=$(( $i + 1 ))
  done
  #
  # In case the regular busybox applets blkid, findfs, ....
  # are failing:  only busybox dd is used 
  if [ "$ROOTDEV" = "" ]; then
    ROOTDEV="$ROOTDEVOLD"
    echoconsole "$INITPREF"  "Rootfilesystem device not correctly detetcted!"
    echoconsole "$INITPREF"  "Rereading without extensive BusyBox use and waiting for it to come up...."
    parse_rootdevice_string
    set_disk_parameters
    for DEV in $PARTDEVS; do
      TOK=LABEL_$DEV
      eval ylabel="\$$TOK"
      if [ "$LABEL" = "$ylabel" ]; then
        ROOTDEV=/dev/$DEV
        echoconsole "$INITPREF" "found by label '$ylabel': up and accessible rootfilesystem device '$ROOTDEV' "  
        break
      else
        echoconsole "$INITPREF" "disklabel '$ylabel' of '/dev/$DEV' not found in '$ROOT'..."
      fi
      TOK=PARTUUID_$DEV
      eval ylabel="\$$TOK"
      if [ "$PARTUUID" = "$ylabel" ]; then
        ROOTDEV=/dev/$DEV
        echoconsole "$INITPREF" "found by partuuid '$ylabel': up and accessible rootfilesystem device '$ROOTDEV' "  
        break
      else
        echoconsole "$INITPREF" "partition-uuid '$ylabel' of '/dev/$DEV' is not in '$ROOT'..."
      fi
    done
  else
    echoconsole "$INITPREF" ".... found: up and accessible rootfilesystem device '$ROOTDEV' "  
  fi 
  #
  # set up root by dialog if missing cmdline parameter
  if [ "$ROOTDEV" = "" -a "$I" != "" ]; then
    start_tracing
    echoconsole "$INITPREF"  " Entering shell prompt to specify interactively "
    echoconsole "$INITPREF"  " the undiscovered rootfilesystem device : "
    boot_device_dialog
    # temporary for testing purposes
    stop_tracing
  fi
#
elif [ "$ROOT" = "" -o "$ROOTDEV" = ""  ];then 
  # temporary for testing purposes
  start_tracing
  if [ "$I" != "" ]; then
    echoconsole "$INITPREF"  "Interactive use specified, entering prompt: "
  else
    echoconsole "$INITPREF" "No root parameter specified, entering unconditional prompt: "
  fi
  inline_external_file "branch-block-functions"
  boot_device_dialog
  # temporary for testing purposes
  stop_tracing
else
  # for ultimate security : more complicated and expensive check of rootdevice
  if ! [ -e "$ROOTDEV" ]; then
    inline_external_file "archvarfile"
    inline_external_file "$ARCH-functions"
    inline_external_file "branch-block-functions"
    boot_device_check
    /bin/busybox sync 
  fi
fi # ROOT != ""
stop_tracing
debug_mark
#
if [ "$NOAUTO" = "" ]; then

  if [ "$EXTENT" = "$SUFFIXKERNVER" ]; then
    # if we have initrd variable correctly set at cmdline 
   if [ "$INITRD" = "" ]; then 
     echoconsole "$INITPREF" "No initrd filename specified!"
   fi
  
   if [ "$INITCMD" != "" ]; then INITRD=$INITCMD; fi
   BOOTINITRD=""
   BOOTKERN=""
   # if a root device to boot to is found
   if [ "$ROOTDEV" != "" ]; then  
      #find initrd file on the initramfs  root  boot/$INITRD
      if [ -e /boot/$INITRD ]; then 
        BOOTINITRD=/boot/$INITRD 
      else
        BOOTINITRD=""
      fi
    if [ "$BOOTINITRD" = "" ]; then  
      echoconsole "$INITPREF" "No initrd file found for optimized reboot"
    elif [ -e "$BOOTINITRD" ]; then
      BOOTKERN="$(echo $KERNVER | /bin/busybox cut -f1 -d- 2>/dev/null)"
      BOOTKERN=`/bin/busybox find /$(/bin/busybox dirname $BOOTINITRD) -name   "vmlinuz-$BOOTKERN-$EXTENT"`
  #  reboot disabled until kexec compilable as static
  #    if [ "$BOOTKERN" != "" ]; then
      #  reboot_hardware_optimized ""
  #    ;
  #    else
   #     echoconsole "$INITPREF" "No kernel of type $(echo $KERNVER | /bin/busybox cut -f1 -d- 2>/dev/null)-$EXTENT found"
   #   fi
    else
       echoconsole "$INITPREF" " No initrd $BOOTINITRD found in /boot/$INITRD for reboot with other kernel !"
    fi
   else
      echoconsole "$INITPREF" " No $ROOTDEV found , retrying to find initrd...."
      if [ -e "$BOOTINITRD" ]; then
         BOOTKERN="$(echo $KERNVER | /bin/busybox cut -f1 -d- 2>/dev/null)"
         BOOTKERN=`/bin/busybox find /$(/bin/busybox dirname $BOOTINITRD) -name "vmlinuz-$BOOTKERN-$EXTENT"`
        # reboot disabled until kexec compilable as static
        # if [ "$BOOTKERN" != "" ]; then
        #  reboot_hardware_optimized ""
        # else
        #  echoconsole "$INITPREF" "No kernel of type $(echo $KERNVER | /bin/busybox cut -f1 -d- 2>/dev/null)-$EXTENT found"
        # fi
      else
         echoconsole "$INITPREF" " No initrd found for reboot with other kernel !"
      fi 
   fi
   #
  else
    echoconsole "$INITPREF" " confirming kernel $KERNVER is no more optimizable for $EXTENT, continuing......."
  fi
  /bin/busybox sync 
fi #  !NOAUTO
#
echoconsole "$INITPREF" "booting into root device '$ROOTDEV' ......"
debug_mark
#
if  [ -e "$ROOTDEV" ]; then
  echoconsole "......and last Verification of Root device '$ROOTDEV' done!"
else
  echoconsole "Root device ' $ROOTDEV ' not found !"
  error2ash "$INITPREF"
fi
#
debug_mark
# Load a custom keyboard mapping: (from SLackware)
if [ -n "$KEYMAP" ]; then
  echoconsole "$INITPREF" " Loading '$KEYMAP' keyboard mapping:"
  /bin/busybox tar xzOf /etc/keymaps.tar.gz ${KEYMAP}.bmap | loadkmap  2>/dev/null
fi
# Rescue mode (from SLackware)
if [ "$RESCUE" != "" ]; then # modified from Slackware
  # branch to rescue mode and perform a simple switch_root, 
  # if otherwise the system with the chroot preference hangs
#  rescue mode
  if ! [ -e $ROOTDEV ]; then
    inline_external_file "branch-block-functions"
    ROOTDEV="$(verify_device "$ROOTDEV")"
  fi
  if  [ -e $ROOTDEV ]; then
    echoconsole "$INITPREF" "root device $ROOTDEV appeared...."
  else
    ROOTDEV="$(verify_device "$ROOTDEV")"
    if ! [ -e $ROOTDEV ]; then
      echoconsole "$INITPREF"  "...root device $ROOTDEV not found , you must specify correct root device or attach the relevant media!"
    fi 
  fi
  echoconsole "$INITPREF" "RESCUE mode"
  echoconsole "$INITPREF" " "
  echoconsole "$INITPREF" "        You can try to fix or rescue your system now. If you want"
  echoconsole "$INITPREF" "        to boot into your fixed system, mount your root filesystem"
  echoconsole "$INITPREF" "        read-only under $ROOTDIR:"
  echoconsole "$INITPREF" "            # mount -o ro -t filesystem root_device $ROOTDIR"
  echoconsole "$INITPREF" "        Type 'exit' when things are done."
  /bin/busybox ash < /dev/console 
  unset ERR
  /bin/busybox umount /proc
  /bin/busybox umount /sys
  echoconsole "$INITPREF" " exiting and switching root to bootfilesystem"
  /bin/busybox switch_root  "$ROOTDIR" "/bin/busybox init" "$RUNLEVEL"
  echobold "$INITPREF" "You arrived at a place in '$0' which should never be reached!"
  echobold  "$INITPREF" " Check your scripts and system setup!"   
  error2ash "$INITPREF"
fi # rescue mode
# Initialize RAID:
if [ "$NORAID" = "" ]; then 
  if [ -x /sbin/mdadm ]; then
    /sbin/mdadm -E -s >/etc/mdadm.conf
    /sbin/mdadm -A -s
  fi
fi # noraid
# Make encrypted root partition available:
# The useable device will be under /dev/mapper/
# Three scenarios for the commandline exist:
# 1- ROOTDEV is on a LUKS volume, and LUKSDEV is a real block device
# 2- ROOTDEV is on a LVM volume, and LUKSDEV is a real block device
# 3- ROOTDEV is on a LUKS volume, and LUKSDEV is on a LVM volume
# Case (3) will have to wait until we initialize the LVM.
# Test if ROOTDEV is "/dev/someting" or just "something" - the first means
# ROOTDEV is on a LVM volume (scenario 2); we don't need to rewrite ROOTDEV.
# The second means that ROOTDEV is on a LUKS volume (scenario 1).
if [ "$NOCRYPT" = "" ]; then
  CRYPTDEV=""
  if [ -x /sbin/cryptsetup ]; then
    # If we find a LUKS device now, it is on a real block device: 
    if /sbin/cryptsetup isLuks ${LUKSDEV} 1>/dev/null 2>/dev/null ; then
      CRYPTDEV=$(/bin/busybox basename $ROOTDEV)
      echoconsole "$INITPREF" "Unlocking LUKS crypt volume '${CRYPTDEV}' on device '$LUKSDEV':"
      /sbin/cryptsetup luksOpen ${LUKSDEV} $CRYPTDEV </dev/systty >/dev/systty 2>&1
      if [ "$CRYPTDEV" = "$ROOTDEV" ]; then # scenario 1
        ROOTDEV="/dev/mapper/${CRYPTDEV}"
      fi
    fi
  fi
  
  # Initialize LVM:
  if [ -x /sbin/vgscan ]; then
    /sbin/vgscan --mknodes --ignorelockingfailure
    sleep 10
    /sbin/vgchange -ay --ignorelockingfailure
  fi
  
  # Make encrypted root partition available (scenario 3):
  # We have to handle cases here where the LUKS volume is created on a LV
  if [ -x /sbin/cryptsetup ]; then
    if /sbin/cryptsetup isLuks ${LUKSDEV} 1>/dev/null 2>/dev/null ; then
      # Only act if we could not open the LUKS device before (i.e. is on a LV):
      if [ "x$CRYPTDEV" = "x" ]; then
        echoconsole "$INITPREF" "Unlocking LUKS crypt volume '${ROOTDEV}' on device '$LUKSDEV':"
        /sbin/cryptsetup luksOpen ${LUKSDEV} $ROOTDEV </dev/systty >/dev/systty 2>&1
        ROOTDEV="/dev/mapper/${ROOTDEV}"
      fi
    fi
  fi

fi # nocrypt
# Resume state from swap
if [ "$RESUMEDEV" != "" ]; then
  if  [ "$(/bin/busybox  ls -l $RESUMEDEV | /bin/busybox cut -c 1 2>/dev/null)" = "l" ] ; then
    RESUMEDEV=`/bin/busybox ls -l $RESUMEDEV | /bin/busybox awk '{ print $NF }'`
  fi
  echoconsole "$INITPREF" "Trying to resume from $RESUMEDEV"
  RESMAJMIN=`/bin/busybox ls -l $RESUMEDEV | /bin/busybox tr , : | /bin/busybox awk '{ print $5$6 }'`
  echo $RESMAJMIN > /sys/power/resume
fi
# if I develop b/ash scripting, I am thinking as a stupid b/ash developer in his world
# not as a kernel developer who knows the next 5 years.
# Therefore, maybe this is enough:
# echo /bin/mdev > /proc/sys/kernel/hotplug
#but I  (C) Dieter Miosga 2009-07-08, did this :
#if ! [ -e "$ROOTDEV" ]; then
# echoconsole "$INITPREF" "Probing for root device '$ROOTDEV' additionally ..."
# inline_external_file "branch-block-functions"
# ROOTDEV="$(verify_device "$ROOTDEV")"
# set_system_variables
#fi
#if  [ -e $ROOTDEV ]; then
#  echoconsole "$INITPREF" "... root device '$ROOTDEV' appeared!"
#else
# ROOTDEV="$(verify_device "$ROOTDEV")"
# set_system_variables
# if [ -e $ROOTDEV ]; then
#   echoconsole "$INITPREF" "... root device '$ROOTDEV' appeared!"
# else
#  echoconsole "$INITPREF"  "... root device '$ROOTDEV' not found. Verify having specified correct root device or attach the relevant media!"
#  error2ash "$INITPREF"
# fi 
#fi

debug_mark
#  wait_for_removable "$WAITFORROOT"
# Switch to real root partition:
MOUNTCMD=""
echoconsole "$INITPREF" "mounting and accessing root at '$ROOTDEV' with '$ROOTFS' ...." 
#echo 0x0100 > /proc/sys/kernel/real-root-dev
if [ "$MOUNTMODE" = "" ]; then MOUNTMODE=ro; fi
if [ "$ROOTFSTYPE" != "" ]; then
   MOUNTCMD=" -n -t $ROOTFSTYPE -o $MOUNTMODE,remount "
else
   MOUNTCMD=" -n -o $MOUNTMODE,remount  "
fi
echoconsole "$INITPREF" "doing a : /bin/busybox mount  $MOUNTCMD $ROOTDEV $ROOTDIR  ......"
/bin/busybox mount  $MOUNTCMD $ROOTDEV $ROOTDIR
if [ $? -ne 0 ]; then 
  echoconsole "$INITPREF" "retrying to mount new root from boot root "
  MOUNTCMD=" -n -o $MOUNTMODE "
  echoconsole "$INITPREF" "redoing mount : /bin/busybox mount  $MOUNTCMD $ROOTDEV $ROOTDIR  "
  /bin/busybox mount  $MOUNTCMD $ROOTDEV $ROOTDIR
  if [ $? -ne 0 ]; then 
    echoconsole "$INITPREF" " last trial with filesystems default "
    MOUNTCMD=" -o $MOUNTMODE "
    echoconsole "$INITPREF" "redoing mount : /bin/busybox mount  $MOUNTCMD $ROOTDEV $ROOTDIR  "
    /bin/busybox mount  $MOUNTCMD $ROOTDEV $ROOTDIR
    if [ $? -ne 0 ]; then 
      MOUNTCMD=""
      echoconsole "$INITPREF" "redoing mount : /bin/busybox mount  $MOUNTCMD $ROOTDEV $ROOTDIR  "
      /bin/busybox mount  $MOUNTCMD $ROOTDEV $ROOTDIR
    fi
  else
    echoconsole "$INITPREF" " mounted $MOUNTCMD $ROOTDEV at $ROOTDIR ! "
  fi
else
  echoconsole "$INITPREF" " mounted $MOUNTCMD $ROOTDEV at $ROOTDIR ! "
fi
#
if [ "$(/bin/busybox ls -1 $ROOTDIR 2>/dev/null)" != ""  ]; then 
  echoconsole "$INITPREF" " successful: '$ROOTDEV' at '$ROOTDIR' accessible in '$MOUNTMODE' "
else
  echoconsole "$INITPREF" "Root device '$ROOTDEV' not mountable at Directory '$ROOTDIR'
    or root filesystem is empty! Reconfigure your system
    or verify the kernel commandline parameters."
  error2ash "$INITPREF"
fi
#
LAYERFS=""
# manage kernel modules 
if [ "$NOMOD" = "" ]; then
  start_tracing
  TARGET_DRIVERS=""
  if [ -e $ROOTDIR/lib/modules/$KERNVER/kernel/drivers ]; then
    TARGET_DRIVERS=""
  else 
    TARGET_DRIVERS="yes"
  fi
  if [ "$LOCAL_DRIVERS" != "" -a "$TARGET_DRIVERS" != "" ]; then
    # prepare the mount command 
    if [ "$OVERLAY" != "" ]; then
      NEWROOTDIR=/mntovl
      #TMPDIR=/tmp
      /bin/busybox mkdir -p $NEWROOTDIR  2>/dev/null
      if [ "$LAYERFS" != "" ]; then
        if `is_not_string_in_file  "$LAYERFS" "/proc/filesystems" `; then 
          /bin/busybox modprobe "$LAYERFS"  2>/dev/null
        fi
        echoconsole "$INITPREF" " Found layerfs '$LAYERFS'"
      else
        LAYERFS=aufs
        if `is_not_string_in_file  "aufs" "/proc/filesystems" `; then 
          /bin/busybox modprobe aufs 2>/dev/null
        fi
        if `is_not_string_in_file  "aufs" "/proc/filesystems" `; then 
          LAYERFS=unionfs
          if `is_not_string_in_file  "unionfs" "/proc/filesystems" `; then 
            /bin/busybox modprobe unionfs 2>/dev/null
          fi
          if `is_not_string_in_file  "unionfs" "/proc/filesystems" `; then 
            LAYERFS=overlayfs
            if `is_not_string_in_file  "overlayfs" "/proc/filesystems" `; then 
              /bin/busybox modprobe overlayfs  2>/dev/null
            fi
          fi
        fi
      fi
      if `is_string_in_file "aufs" "/proc/filesystems" ` && [ "$LAYERFS" = "aufs" ]; then
        #mount -t aufs -o udba=reval,diropq=w,dirs=$ROOTDIR=$MOUNTMODE:/lib/modules/$KERNVER=ro:$MODTMPDIR=ro   none   $NEWROOTDIR
        mount -t aufs -o udba=reval,diropq=w,dirs=$ROOTDIR=$MOUNTMODE:$MODTMPDIR=ro   none   $NEWROOTDIR
        RC=$?
      elif `is_string_in_file "unionfs" "/proc/filesystems" ` && [ "$LAYERFS" = "unionfs" ]; then
        mount -t unionfs -o dirs=$ROOTDIR=$MOUNTMODE:$MODTMPDIR=ro  none  $NEWROOTDIR
        #mount -t unionfs -o dirs=$ROOTDIR=$MOUNTMODE:/lib/modules/$KERNVER=ro:$MODTMPDIR=ro  none  $NEWROOTDIR
        RC=$?
      elif `is_string_in_file "overlayfs" "/proc/filesystems" `  && [ "$LAYERFS" = "overlayfs" ]; then
        mount -t overlayfs -o dirs=$ROOTDIR=$MOUNTMODE:$MODTMPDIR=ro  none  $NEWROOTDIR
        #mount -t overlayfs -o dirs=$ROOTDIR=$MOUNTMODE:/lib/modules/$KERNVER=ro:$MODTMPDIR=ro  none  $NEWROOTDIR
        RC=$?
      fi
      echoconsole "$INITPREF" "Established layerfs '$LAYERFS' mount with '$RC'"
      /bin/busybox mkdir -p $NEWROOTDIR/lib  2>/dev/null
      /bin/busybox mkdir -p $NEWROOTDIR/lib/modules  2>/dev/null
      /bin/busybox mkdir -p $NEWROOTDIR/lib/modules/$KERNVER   2>/dev/null
      /bin/busybox mkdir -p $NEWROOTDIR/lib/modules/$KERNVER/kernel   2>/dev/null
      /bin/busybox cp -f -a -u /lib/modules/$KERNVER/modules.*   $NEWROOTDIR/lib/modules/$KERNVER/ 2>/dev/null
      #/bin/busybox mount -o move  /lib/modules/$KERNVER/kernel  $NEWROOTDIR/lib/modules/$KERNVER/kernel  2>/dev/null
      /bin/busybox mkdir -p $NEWROOTDIR/$MODTMPDIR  2>/dev/null
      #/bin/busybox mount -t tmpfs    tmpfs $NEWROOTDIR/$MODTMPDIR  2>/dev/null
      #/bin/busybox cp -f -a -u $KERNELFILE  $NEWROOTDIR/  2>/dev/null
      #/bin/busybox mount -o move  /lib/modules/$KERNVER/kernel  $NEWROOTDIR/lib/modules/$KERNVER/kernel  2>/dev/null
      SIZE=`/bin/busybox ls -1s $KERNELFILE  2>/dev/null`
      SIZE=${SIZE%$KERNELFILE}
      # size in bytes
      SIZE=$(( $SIZE * 1024 ))
      # add 5% of security buffer
      SIZE=$(( $SIZE + 5 * $SIZE / 100 ))
      /bin/busybox mount -n -t tmpfs -o size=$SIZE  tmpfs  $NEWROOTDIR/$MODTMPDIR  2>/dev/null
      /bin/busybox cp -f -a -u $KERNELFILE  $NEWROOTDIR/$MODTMPDIR/  2>/dev/null
       #/bin/busybox mount -o move  $MODTMPDIR $NEWROOTDIR/$MODTMPDIR  2>/dev/null
      /bin/busybox mount -t squashfs -o ro,loop $NEWROOTDIR/$MODTMPDIR/$KERNELFILE  $NEWROOTDIR/lib/modules/$KERNVER/kernel  2>/dev/null
      /bin/busybox cp -f -a -u /lib/modules/$KERNVER/modules.*   $NEWROOTDIR/lib/modules/$KERNVER/ 2>/dev/null
      /bin/busybox umount $KERNELFILE  2>/dev/null
       OLDROOTDIR="$ROOTDIR"
      #ROOTDIR="$NEWROOTDIR"
      /bin/busybox cp -f -a -u /dev/*  $NEWROOTDIR/dev/ 2>/dev/null
      echoconsole "$INITPREF" "Prepared layerfs '$LAYERFS' for '$NEWROOTDIR' with '$ROOTDIR' as a branch "
    fi
  fi
  stop_tracing
fi 
#

# find chroot, switch_root and init
#
#
INITBB=""
CHROOTBB=""
SWITCHROOTBB=""
#
if [ -x /bin/busybox ];       then  
   CHROOTBB="/bin/busybox chroot"
   SWITCHROOTBB="/bin/busybox switch_root"
fi
#
if [ -x /bin/busybox ];       then  
  INITBB="/bin/busybox init"
fi
#
start_tracing
if [ "$CHROOT" != "" ];  then
  if [ -x $ROOTDIR/$CHROOT ];  then  
    echoconsole "$INITPREF" "Specified chroot  command '$ROOTDIR/$CHROOT' exists and is executable!"
  else
    echoconsole "$INITPREF" "Specified chroot command '$ROOTDIR/$CHROOT' not found or not executable!"
    echoconsole "$INITPREF" "Continuing checking for some predefined usual values....."
  fi
fi
if [ "$CHROOT" = "" ]; then 
  for chrootcmd in $CHROOT_SEARCH_FILES; do
    if [ -e $ROOTDIR/$chrootcmd ];  then 
      CHROOT="$chrootcmd"
      chroot2=`/bin/busybox readlink -f "$ROOTDIR/$chrootcmd" 2>/dev/null`
      chroot2="${chroot2#$ROOTDIR/}"
      if [ "$CHROOT" != "$chroot2" ]; then
	CHROOT="$chroot2"
      fi
      if [ -x "$ROOTDIR/$CHROOT" ];  then 
	  export CHROOT=./$CHROOT
	  break
      fi
    fi
  done
fi
if [ "$SWITCH_ROOT" != "" -a "$SWITCHROOT" = "" ]; then 
  SWITCHROOT="$SWITCH_ROOT"
fi

if [ "$SWITCHROOT" != "" ];  then
  if [ -x $ROOTDIR/$SWITCHROOT ];  then  
    echoconsole "$INITPREF" "Specified chroot  command '$ROOTDIR/$SWITCHROOT' exists and is executable!"
  else
    echoconsole "$INITPREF" "Specified chroot command '$ROOTDIR/$SWITCHROOT' not found or not executable!"
    echoconsole "$INITPREF" "Continuing checking for some predefined usual values....."
  fi
fi
if [ "$SWITCHROOT" = "" ]; then 
  for switchrootcmd in $SWITCHROOT_SEARCH_FILES; do
    if [ -e $ROOTDIR/$switchrootcmd ];  then 
      SWITCHROOT="$switchrootcmd"
      switchroot2=`/bin/busybox readlink -f "$ROOTDIR/$switchrootcmd" 2>/dev/null`
      switchroot2="${switchroot2#$ROOTDIR/}"
      if [ "$SWITCHROOT" != "$switchroot2" ]; then
	SWITCHROOT="$switchroot2"
      fi
      if [ -x "$ROOTDIR/$SWITCHROOT" ];  then 
	  export SWITCHROOT=./$SWITCHROOT
	  break
      fi
    fi
  done
fi
#  prefer a custom init 
if [ "$INIT" != "" ];  then
  if [ -x $ROOTDIR/$INIT ];  then  
    echoconsole "$INITPREF" "Specified init command '$ROOTDIR/$INIT' exists and is executable!"
    echoconsole "$INITPREF" "Continuing checking with some predefined usual values....."
  else
    echoconsole "$INITPREF" "Specified init command '$ROOTDIR/$INIT' not found or not executable!"
    echoconsole "$INITPREF" "Continuing checking with some predefined usual values....."
  fi
fi
if [ "$INIT" = "" ]; then 
  for initcmd in $INIT_SEARCH_FILES; do
    if [ -e $ROOTDIR/$initcmd ];  then 
      INIT="$initcmd"
      init2=`/bin/busybox readlink -f "$ROOTDIR/$initcmd" 2>/dev/null`
      init2="${init2#$ROOTDIR/}"
      if [ "$INIT" != "$init2" ]; then
	INIT="$init2"
      fi
      if [ -x "$ROOTDIR/$INIT" ];  then 
	  export INIT=./$INIT
	  break
      fi
    fi
  done
fi
stop_tracing
#
/bin/busybox sync
#
if  [ "$INIT" != "" ]; then
  echoconsole "$INITPREF" " INIT : validated  '$INIT ' found on root device $ROOTDEV ."
else
  echoconsole "$INITPREF" "ERROR: No init command (sbin/init, bin/init,....) found on root device $ROOTDEV ."
fi
#
remount_rw()
{
  if [ "`/bin/busybox grep "$ROOTDIR" </proc/mounts  2>/dev/null | /bin/busybox grep "ro," 2>/dev/null`" != "" ]; then
	  #/bin/busybox   umount  $ROOTDIR    2>/dev/null
	  /bin/busybox   mount   $MOUNTCMD -o rw,remount  $ROOTDEV  $ROOTDIR  2>/dev/null
  fi
}

remount_ro()
{
  if [ "`/bin/busybox grep "$ROOTDIR" </proc/mounts  2>/dev/null | /bin/busybox grep "rw," 2>/dev/null`" != "" ]; then
	  #/bin/busybox  umount $ROOTDIR    2>/dev/null
	  /bin/busybox   mount $MOUNTCMD -o ro,remount $ROOTDEV  $ROOTDIR  2>/dev/null
  fi
}
#
debug_mark
# make sure some devices are there if explicitly specified
if [ "$MAKEDEVS" != "" ]; then
#
  if ! [ -e $ROOTDIR/dev/console ]; then
    remount_rw
    /bin/busybox mknod $ROOTDIR/dev/console c 5 1  2>/dev/null
    RC=$?
    if [ $? -ne 0 ]; then 
      echoconsole "$INITPREF" " $ROOTDIR/dev/console not created without errors: '$RC' "
    else
      echoconsole "$INITPREF" " $ROOTDIR/dev/console created: '$RC' "
    fi
  fi
  #
  if ! [ -e $ROOTDIR/dev/initctl ]; then
    remount_rw
    /bin/busybox mkfifo -m 0755 $ROOTDIR/dev/initctl 2>/dev/null
    RC=$?
    if [ $? -ne 0 ]; then 
      echoconsole "$INITPREF" " $ROOTDIR/dev/initctl not created without errors: '$RC' "
    else
      echoconsole "$INITPREF" " $ROOTDIR/dev/initctl created: '$RC' "
    fi
  fi
  #
  if ! [ -e $ROOTDIR/dev/tty ]; then
    remount_rw
    /bin/busybox mknod -m 0660 $ROOTDIR/dev/tty c 6 1 2>/dev/null
    RC=$?
    if [ $? -ne 0 ]; then 
      echoconsole "$INITPREF" " $ROOTDIR/dev/tty not created without errors: '$RC' "
    else
      echoconsole "$INITPREF" " $ROOTDIR/dev/tty created: '$RC' "
    fi
    for i in 0 1 2 3 4 5 6 7; do
      /bin/busybox mknod -m 0660 $ROOTDIR/dev/tty$i c $(( 7 + $i )) 1 2>/dev/null
      RC=$?
      if [ $? -ne 0 ]; then 
	echoconsole "$INITPREF" " $ROOTDIR/dev/tty$i not created without errors: '$RC' "
      else
	echoconsole "$INITPREF" " $ROOTDIR/dev/tty$i created: '$RC' "
      fi
    done
    /bin/busybox mknod -m 0660 $ROOTDIR/dev/ttyprintk c 18 1 2>/dev/null
    RC=$?
    if [ $? -ne 0 ]; then 
      echoconsole "$INITPREF" " $ROOTDIR/dev/ttyprintk not created without errors: '$RC' "
    else
      echoconsole "$INITPREF" " $ROOTDIR/dev/ttyprintk created: '$RC' "
    fi
  fi
  #
  if ! [ -e $ROOTDIR/dev/null ]; then
    remount_rw
    /bin/busybox mknod $ROOTDIR/dev/null c 1 3   2>/dev/null
    if [ $? -ne 0 ]; then 
      RC=$?
      echoconsole "$INITPREF" " $ROOTDIR/dev/null not created without errors: '$RC' "
    fi
  fi
#
fi
#
if ! [ -e /dev/initctl ]; then 
  /bin/busybox mkfifo -m 0755 /dev/initctl   2>/dev/null
fi
#
if ! [ -e /dev/console  ]; then 
  /bin/busybox mknod /dev/console c 5 1  2>/dev/null
  if [ $? -ne 0 ]; then 
    RC=$?
    echoconsole "$INITPREF" "/dev/console not created without errors: '$RC' "
  fi
fi
#
if ! [ -e  dev/console  ]; then 
  /bin/busybox mknod  dev/console c 5 1  2>/dev/null
  if [ $? -ne 0 ]; then 
    RC=$?
    echoconsole "$INITPREF" "  dev/console not created without errors: '$RC' "
  fi
fi
#

debug_mark
#
if [ "$MOUNTMODE" = "ro" ]; then
   remount_ro
fi

if [ "`/bin/busybox grep $ROOTDIR < /proc/mounts | /bin/busybox grep "rw," 2>/dev/null`" != "" ]; then
  if [ "$INITDBG" = "initdbg" -o $INITDBG -ge 3 ]; then 
    /bin/busybox mkdir -p $ROOTDIR/var      2>/dev/null
    /bin/busybox mkdir -p $ROOTDIR/var/log   2>/dev/null
    /bin/busybox dmesg >>  $MSGFILE   2>/dev/null
    /bin/busybox cp -f $MSGFILE   $ROOTDIR/var/log  2>/dev/null
  fi 

else
  echoconsole "$INITPREF" "Booting in read-only mode'"
  echoconsole "$INITPREF" "not saving messagefiles and changes to target '$ROOTDEV'"
fi
#
if [ "$LAYERFS" != ""  ]; then 
   /bin/busybox mount  -o remount,rw /
fi
#
unset ERR
#
echoconsole "$INITPREF" "${INITRD}:  exiting and switching to target rootfilesystem at $ROOTDEV....."
debug_mark

start_tracing
# TODO: check for rootfs-switch more comfortable
if [ "$ROOTSWITCH" = "" ]; then
   #inline_external_file "initvariables"
   inline_external_file "yainitdefaults"
   /bin/busybox sync
fi

if [ "$ROOTSWITCH" = "" ]; then
  ROOTSWITCH=chroot
fi
if [ "$SWITCHROOT" != "" -a "$CHROOT" = "" ]; then
  ROOTSWITCH=switch_root
fi
inline_external_file "filesys-functions"
/bin/busybox sync
# find the correct root directory to switch to
if `is_string_in_file "aufs" "/proc/mounts" ` && [ "$LAYERFS" = "aufs" ] ; then
  cd $NEWROOTDIR
  #sbin/depmod -a 2>/dev/null
  #[ $? -ne 0 ] && bin/depmod -a 2>/dev/null
  #[ $? -ne 0 ] && usr/sbin/depmod -a 2>/dev/null
  #[ $? -ne 0 ] && usr/bin/depmod -a 2>/dev/null
  #ROOTSWITCH="switch_root"
elif `is_string_in_file "unionfs" "/proc/mounts" ` && [ "$LAYERFS" = "unionfs" ] ; then
  cd $NEWROOTDIR
  sbin/depmod -a 2>/dev/null
  [ $? -ne 0 ] && bin/depmod -a 2>/dev/null
  [ $? -ne 0 ] && usr/sbin/depmod -a 2>/dev/null
  [ $? -ne 0 ] && usr/bin/depmod -a 2>/dev/null
elif `is_string_in_file "overlayfs" "/proc/mounts" ` && [ "$LAYERFS" = "overlayfs" ] ; then
  cd $NEWROOTDIR
  sbin/depmod -a 2>/dev/null
  [ $? -ne 0 ] && bin/depmod -a 2>/dev/null
  [ $? -ne 0 ] && usr/sbin/depmod -a 2>/dev/null
  [ $? -ne 0 ] && usr/bin/depmod -a 2>/dev/null
else
  cd   $ROOTDIR
fi
unmount_procfs_sysfs
/bin/busybox sync
#if [ $(/bin/busybox wc -l </proc/mounts 2>/dev/null) -gt 1 ]; then 
#  unmount_all_nodev_filesystems
#  /bin/busybox sync
#fi
stop_tracing
MNTFSYS=`/bin/busybox cat /proc/mounts 2>/dev/null`
if [ "$MNTFSYS" != "" ]; then
  echoconsole  "$INITPREF"  "Mounted Filesystems: '$MNTFSYS' "
fi
if [ "$CHROOTBB" != "" -a "$ROOTSWITCH" = "chroot" ]; then
  cd   $ROOTDIR
  echoconsole "$INITPREF" "${INITRD} @DIR:`pwd`:  ...issuing command: exec  $CHROOTBB ./ $INIT $RUNLEVEL < dev/console > dev/console 2>&1"

  debug_mark
  exec  $CHROOTBB  ./  $INIT  $RUNLEVEL  < dev/console > dev/console 2>&1
  if [ $? -ne 0 ]; then 
    echoconsole "$INITPREF" "${INITRD}:  changing root to bootfilesystem $ROOTDIR not successfull, retrying....."
    cd   $ROOTDIR
    echoconsole "$INITPREF" "${INITRD} @DIR:`pwd`:  ...issuing command: exec  $CHROOTBB ./ $INITBB $RUNLEVEL < dev/console > dev/console 2>&1"
    exec  $CHROOTBB  ./  $INITBB  $RUNLEVEL  < dev/console > dev/console 2>&1
    exec $CHROOTBB  ./  etc/rc.d/rc.S   < dev/console > dev/console 2>&1
  fi

  export PATH=$PATH:$ROOTDIR/bin:$ROOTDIR/sbin:$ROOTDIR/usr/bin:$ROOTDIR/usr/sbin
fi

if [ "$SWITCHROOTBB" != "" -a "$ROOTSWITCH" = "switch_root" ]; then
  cd   $ROOTDIR
  echoconsole "$INITPREF" "${INITRD}:`pwd`:  ...issuing command: exec  $SWITCHROOTBB $ROOTDIR $INIT $RUNLEVEL <dev/console >dev/console 2>&1"

  debug_mark
  exec  $SWITCHROOTBB   $ROOTDIR  $INIT  $RUNLEVEL  < dev/console > dev/console 2>&1
  if [ $? -ne 0 ]; then 
    echoconsole "$INITPREF" "${INITRD}:  changing root to bootfilesystem $ROOTDIR not successfull, retrying....."
    cd   $ROOTDIR
    exec  $SWITCHROOTBB   $ROOTDIR  $INITBB  $RUNLEVEL  < dev/console > dev/console 2>&1
    #exec $CHROOTBB  ./  etc/rc.d/rc.S   < dev/console > dev/console 2>&1
  fi
  export PATH=$PATH:$ROOTDIR/bin:$ROOTDIR/sbin:$ROOTDIR/usr/bin:$ROOTDIR/usr/sbin
fi


if [ -e $CHROOT -a "$ROOTSWITCH" = "chroot" ]; then
  cd   $ROOTDIR
  echoconsole "$INITPREF" "${INITRD} @DIR:`pwd`:  ...issuing command: exec  $CHROOT ./ $INIT $RUNLEVEL < dev/console > dev/console 2>&1"

  debug_mark
  exec  $CHROOT  ./  $INIT $RUNLEVEL  < dev/console > dev/console 2>&1
  echoconsole "$INITPREF" "${INITRD}: failed chroot with system commands, falling back to busybox commands...."
  export PATH=$PATH:$ROOTDIR/bin:$ROOTDIR/sbin:$ROOTDIR/usr/bin:$ROOTDIR/usr/sbin
fi

if [ -e $SWITCHROOT -a "$ROOTSWITCH" = "switch_root" ]; then
  echoconsole "$INITPREF" "${INITRD}:  ....switching root with $SWITCHROOT to bootfilesystem $ROOTDIR at $ROOTDEV"
  cd  $ROOTDIR
  debug_mark
  
  exec $SWITCHROOT -c /dev/console $ROOTDIR  $INIT $RUNLEVEL  < dev/console > dev/console 2>&1
  echoconsole "$INITPREF" "${INITRD}: failed switch_root with system commands, falling back to busybox commands...."
  export PATH=$PATH:$ROOTDIR/bin:$ROOTDIR/sbin:$ROOTDIR/usr/bin:$ROOTDIR/usr/sbin 
fi

cd /
echoconsole "$INITPREF" "${INITRD}:  falling back to $0-switch_root...... "
debug_mark
exec switch_root -c /dev/console $ROOTDIR  $INIT $RUNLEVEL  < dev/console > dev/console 2>&1
# at last:
cd   $ROOTDIR
exec $CHROOTBB ./  2>/dev/null  
echobold "$INITPREF" "You arrived at a place in '$0' which should never be reached!"
echobold "$INITPREF" " Check your scripts and system setup and correct it!" 
error2ash "$INITPREF"

exit 99
#

