#
#  INIT-FUNCTIONS for Universal INIT with busybox
#  (C) Dieter Miosga , 2008-2014-07-13, dieter.miosga@gmx.de 
#
#set -x
#DELAY=delay
#
create_rootfs_dirs()
{
   local DIRS ARG
   if [ "$SYSTEMDIRECTORIES" != "" ]; then
     DIRS="$SYSTEMDIRECTORIES"
     export SYSTEMDIRECTORIES
   else
     DIRS="dev dev/input dev/usb dev/net dev/shm dev/pts dev/fd dev/block dev/disk etc etc/sysconfig etc/init.d etc/rc.d  etc/udev memory union root run sys proc bin sbin usr lib lib/modules lib/libexec tmp mnt var opt usr/bin usr/sbin usr/lib usr/libexec usr/share usr/local usr/local/bin usr/local/sbin usr/local/lib usr/local/libexec usr/local/share var/lock var/log var/run usr/share bbsymlinx"
   fi

  for ARG in $DIRS; do
   #[ -d $1/$ARG ] || /bin/busybox mkdir -p $1/$ARG  2>/dev/null
   /bin/busybox mkdir -p $1/$ARG  2>/dev/null
  done

}
#
build_rootfs()
{
  /bin/busybox mkdir -p -m 0755 /dev
  /bin/busybox mkdir -p -m 0700 /root
  [ -e /dev/console ] || /bin/busybox  mknod -m 0700 /dev/console c 5 1
  [ -e /dev/null ]    || /bin/busybox  mknod /dev/null c 1 3
  > /dev/.initramfs-tools
  /bin/busybox mkdir -p /dev/.initramfs
  #create_rootfs_dirs ""
  
}
#
bbversion_check()
{
  local BBVER BBMAXVER BBMINVER
  BBMINVER=""
  BBMAXVER=""
  BBVER=""
  BBVER=$(/bin/busybox --help 2>/dev/null)
  # version with creation date
  BBVER=${BBVER:9:37}
  if [ "$BBVER" != "" ]; then
    BBMAXVER=${BBVER//.*}
    BBVER=${BBVER#*.}
    BBMINVER=${BBVER//.*}
    if [ $BBMINVER -lt 18 -o $BBMAXVER -lt 1 ]; then  
      export ECHOTEXT="$ECHOTEXT
  $INITPREF Wrong version $BBVER of BusyBox , must be greater or equal 1.18!"
      SYSERRPROMPT=yes
      echo "$ECHOTEXT"
      error2ash "fatal version error for busybox executable"
      return 1
    fi
    return 0
  else
      export ECHOTEXT="$ECHOTEXT
  $INITPREF Fatal configuration error for BusyBox , cannot read correctly system version !"
      SYSERRPROMPT=yes
      echo "$ECHOTEXT"
      error2ash "fatal error for busybox executable"
      return 1
  fi
}
#
bbapplets_check()
{
  if [ "$MINIMAL_YAINIT_BBALIASES" != "" ]; then
    local applet ALLBBAPPLETS RC
    ALLBBAPPLETS=""
    ALLBBAPPLETS=`/bin/busybox --list 2>/dev/null | /bin/busybox tr "\n" " " 2>/dev/null`
    applet=""
    if [ "$ALLBBAPPLETS" != "" ]; then
      for applet in $MINIMAL_YAINIT_BBALIASES; do
        if `is_not_substring_of " $applet " " $ALLBBAPPLETS "`; then
          export ECHOTEXT="$ECHOTEXT
$INITPREF Applet '$applet' not found in preconfigured BusyBox-Applets! "
          SYSERRFATAL=yes
          echo "$ECHOTEXT"
          error2ash "fatal configuration error for busybox executable"
          return 1
        fi
      done
      export ECHOTEXT="$ECHOTEXT
$INITPREF All necessary BusyBox - Applets found ! "
      return 0
    else
      # in case of exception the more expensive way:
      for applet in $MINIMAL_YAINIT_BBALIASES; do
        RC=""
        ALLBBAPPLETS=`/bin/busybox "$applet" --help 2>/dev/null`
        RC=$?
        if  [ $RC -ne 0 ] ; then
          export ECHOTEXT="$ECHOTEXT
$INITPREF Applet '$applet' not found in well preconfigured BusyBox-Applets!"
          SYSERRFATAL=yes
          echo "$ECHOTEXT"
          error2ash "fatal configuration error for busybox executable"
          return 1
        fi
      done
      export ECHOTEXT="$ECHOTEXT
$INITPREF All necessary BusyBox - Applets found ! "
      return 0
    fi
  else 
    export ECHOTEXT="$ECHOTEXT
$INITPREF No minimal applet subset specified for BusyBox, continuing....."
    return 1
  fi
}
#
set_bbsymlinks()
{
  # now create symlinks 
  cd /bin
  /bin/busybox  --install -s
  cd /
  /bin/busybox ln -sf /bin/busybox /bin/sh  2>/dev/null
  #if [ -e /sbin/busybox ]; then /bin/busybox rm  /sbin/busybox  2>/dev/null ;fi
  /bin/busybox sync 2>/dev/null
}
#
# optimizes any binary executable, for that a replacement with
# an extension for local processor is present 
cmdset_optimize()
{
  # $1 = calling function id, $2 = executable to optimize
  # set arch optimization variables
  if [ "$CPUINFO" = "" ]; then 
     ECHOTEXT="$ECHOTEXT
$1 No cpu information "
     export ECHOTEXT="$ECHOTEXT
$1 missing CPU information from /proc/cpuinfo - continuing with default '$2'"          
     return 1
  fi
  if [ "$MAXCMDSET" =  "" ]; then 
     ECHOTEXT="$ECHOTEXT
$1 nothing optimized (1)"
     export ECHOTEXT="$ECHOTEXT
$1 missing processor commandset information - continuing with default '$2'"
     return 1 
  fi
  #set -x     
  ECHOTEXT="$ECHOTEXT
$1 Running on a machine '$CPUMODEL'"
  export ECHOTEXT="$ECHOTEXT
$1 capable for processor instructions '$MAXCMDSET' "
  if [ "$EXTENDU" =  "" ]; then 
    ECHOTEXT="$ECHOTEXT
$1 nothing optimized (1) processor characteristics not discovered"
    export ECHOTEXT="$ECHOTEXT
$1 missing file-extension/cpu-abbreviation - continuing with default '$2'"
    return 1 
  fi
  export ECHOTEXT="$ECHOTEXT
$1 with processor specification '$EXTENDU'"
  if [ "$2" = "" ]; then 
    ECHOTEXT="$ECHOTEXT
$1 nothing optimized (5) "
    export ECHOTEXT="$ECHOTEXT
$1 missing executable specification - continuing with default"
    return 5 
  fi                                         
  local XUTABLE
  XUTABLE="$2"
  #  and install the right one version of executable  if existent
  if [ "$(/bin/busybox ls -1 $XUTABLE-$EXTENDU 2>/dev/null)" != "" ]; then  
    ECHOTEXT="$ECHOTEXT 
$1 found '$XUTABLE' and optimizing it ..."
    # save original version
    /bin/busybox cp -af $XUTABLE $XUTABLE_native  2>/dev/null
    # replace with optimized
    /bin/busybox mv  -f $XUTABLE-$EXTENDU $XUTABLE  2>/dev/null
    # save optimzed actual version
    /bin/busybox cp -af $XUTABLE-$EXTENDU $XUTABLE_optimized  2>/dev/null
    ECHOTEXT="$ECHOTEXT 
$1 ...done: optimized '$XUTABLE' for '$ARCH' architecture" 
    ECHOTEXT="$ECHOTEXT 
$1 and '$CPUMODEL' "
    export ECHOTEXT="$ECHOTEXT 
$1 with '$MAXCMDSET'  extension"
    /bin/busybox rm $XUTABLE-*  2>/dev/null
    #set +x
    return 0
  fi
  ECHOTEXT="$ECHOTEXT 
$1 nothing optimized (127)"
  export ECHOTEXT="$ECHOTEXT 
$1 '$XUTABLE-$EXTENDU' file not found, continuing with default "
  #set +x
  return 127

}
#
set_shellvariables()
{
  #  generate the variables for reading cmdline into shell variables
  # this transforms names in a variable of the form  "a b= c d="
  # to the processable variable declarations    A=$a B=$b C=$c D=$d 
  if [ "$SHELLVARIABLES" = "" ]; then
    echoconsole "$1" " Can not set variables for shell," 
    echoconsole "$1" " No variables specified in yainitdefaults !"
    return 255
  fi
  local VAR HVAR SHELLVARNAMES TOEVAL SHELLVARSTRING
  VAR=""
  HVAR=""
  SHELLVARSTRING=""
  # check for duplicates, uppercases and nonexistent positives ( no no-prefix)
  for VAR in $SHELLVARIABLES; do
    HVAR="$(echo $VAR | /bin/busybox tr  [:upper:] [:lower:] 2>/dev/null)"
    # for all NO*  parameters do truncate NO and take the rest as new parameter
    if `is_substring_of  " $HVAR " " $SHELLVARSTRING "`; then        
      SHELLVARSTRING="$HVAR $SHELLVARSTRING"
    fi
    # for every parameter starting with 'no', create a positive one too 
    case $HVAR in
      no*)
        HVAR="$(echo $HVAR | /bin/busybox cut -c 3- 2>/dev/null)"
        if `is_substring_of  " $HVAR " " $SHELLVARSTRING "`; then        
           SHELLVARSTRING="$HVAR $SHELLVARSTRING"
        fi
      ;;
    esac   
  done
  
  #echo "# variables for cmdline recognition in linux shell" >> shellvars

  SHELLVARNAMES=""
  TOEVAL=""
  #  root=abcde --> $root --> ROOT=$root --> echo $ROOT ==> abcde
  for VAR in $SHELLVARSTRING; do
    HVAR="$(echo $VAR | /bin/busybox  cut -f1 -d '=' 2>/dev/null)"
    #if [ "$VAR" != "$HVAR" ]; then 
    VAR=$HVAR
    #fi
    HVAR="$(echo $VAR | /bin/busybox tr [:lower:] [:upper:] 2>/dev/null)"
    # do not overwrite system variables presetting, only do it by commandline
    TOEVAL="TOEVAL=\$$HVAR"
    eval $TOEVAL
    if [ "$TOEVAL" = "" ]; then
      TOEVAL="$HVAR=\"\$$VAR\""
    else
      TOEVAL="$HVAR=\$$HVAR"
    fi
    eval $TOEVAL
    #echo "$TOEVAL" >> shellvars
    if [ "$HVAR" != "" ]; then 
      export "$HVAR"
      SHELLVARNAMES="$HVAR $SHELLVARNAMES"
    fi
  done
  
  export ALLSHELLVARS="$SHELLVARNAMES"
  
  return 0
}
#
evaluate_shellvar_aliases()
{

  if [ "$SHELLVARALIASES" != "" ]; then
    local VAR HVAR TOEVAL KVAR
    VAR=""
    HVAR=""
    KVAR=""
  
    # evaluate aliases!
    #  nocd=nodvd --> NOCD=$NODVD (<-- NODVD=$nodvd <-- nodvd=nodvd from before) 
    for VAR in $SHELLVARALIASES; do
      HVAR="$(echo $VAR | /bin/busybox  cut -f1 -d '=' 2>/dev/null  | /bin/busybox tr [:lower:] [:upper:] 2>/dev/null)"
      VAR="$(echo $VAR  | /bin/busybox  cut -f2- -d '=' 2>/dev/null | /bin/busybox tr [:lower:] [:upper:] 2>/dev/null | /bin/busybox tr ".-" "_" 2>/dev/null)"
      # is $$VAR noeval t empty? then set $HVAR
      KVAR=""
      if [ "$VAR" != "" ];then 
        eval "KVAR=\"\$$VAR\""
      fi
      if [ "$KVAR" != "" ]; then
        TOEVAL="$HVAR=\"\$$VAR\""
        #echo "$TOEVAL" >> shellvars
        eval $TOEVAL
        export "$HVAR"
      fi
    done
    
    return 0
  else
    return 255
  fi

}
#UNARYVARS=""
#SHELLVARS=""
#
read_cmdline()
{
  # this is a function to read variables from linux kernel /proc/cmdline
  # It requires the preceding set_shellvars function to generate
  # and read in the necessary variables for the init scripts
  # The discovered unary variables in the cmdline are generated anyway
  # and will be checked for internal use according a predefinition 
  # in $SHELLVARIABLES in the variable presetting for YaIniT-init
  # and will be read into running init by the "." (source) statement.
  # The code is shortened and fastened by shrinking a necessary case statement
  # to two small sections , one for dual variables (assignments) and one for
  # special assignments with assurance of the effect of denied parameters
  # by repetitively specifying with other value (the last! validates)
  #
  # OEUVRE DE MAITRE, The ultimate solution for this problem
  # (C) Dieter Miosga <dieter.miosga@gmx.de> 2009-December-through-2014-03-31
  local ARG VAR HVAR  TOEVAL
  
  ARG=""
  VAR=""
  HVAR=""
  TOEVAL=""
  
  for ARG in `/bin/busybox  cat /proc/cmdline 2>/dev/null`  ; do
    # save root=* or boot=* or gernerally x=* parameters as variable assignments 
    # this is necessary for parameters specfied in bootmanager configuration file
    # and added contradictory ones by hand - to make the change active.
    
    #  eliminate dots by converting them to underscore. Dots do not work in shell variables.
    # is there a  tr "\"" "\\""  necessary to make recognize 
    # the blanks in between " "-delimiters as variable content for MicrosoftDirectoryNames???.
    case $ARG in
      # assign non transient cmdline parameters a well defined variable
      # the dots in unary parameters cannot be taken in a variable name => "." -> "_"
      *=*)
        VAR=`echo ${ARG//=*}  | /bin/busybox tr [:lower:] [:upper:] 2>/dev/null | /bin/busybox tr ".-" "_" 2>/dev/null`
        HVAR=${ARG#*=}
      ;;
      *)
         VAR=`echo $ARG |  /bin/busybox tr [:lower:] [:upper:] 2>/dev/null | /bin/busybox tr ".-" "_" 2>/dev/null`
         HVAR="$ARG"
         # evaluate some special cases
         case $VAR in
            0|1|2|3|4|5|6|S)
              VAR=RUNLEVEL
              HVAR=$ARG
            ;;
            NOSWAP)
              export SWAPDEV=""
            ;;
            NORESUME)
              export RESUMEDEV=""
            ;;
            DEBUG)
              export DEBUG_IS_ENABLED="debug_is_enabled"
              export EMSG=""
            ;;
            QUIET)
              export VERBOSE=""
              export EMSG="2>/dev/null"
            ;;
            VERBOSE)
              export VERBOSE=5 
              export QUIET="" 
              export EMSG=""
            ;;
            RW|RO)
              export MOUNTMODE="$HVAR"
            ;;
            NOWAIT)
              VAR=WAIT
              HVAR=0
              wait=0
              export WAITFORROOT=0 
              export SYSWAIT=0
            ;;
            NONET)
              export IP="" ip="" ETH="" WLAN=""
            ;;
            TORAM)
              copy2ram=copy2ram
              export COPY2RAM=copy2ram
            ;;
         esac
    ;;
    esac
    TOEVAL="$VAR=\"$HVAR\""
    eval   "$TOEVAL"
    export "$VAR"

  done



  if [ "$RUNLEVEL" = "" ]; then  RUNLEVEL=$DEFRUNLEVEL;  fi

  #if [ "$LOGLEVEL" = "7" ]; then DEBUG=debug; DEBUG_ENABLED=$DEBUG; fi

  # for now default logging level, switched on here


  export RUNLEVEL QUIET VERBOSE
 
  #
}
#
assign_uuidlabel()
{
  local D d
  if [ "$1" = "" ]; then echo ""; return 1; fi
  D=$1
  d=`echo $D | /bin/busybox tr [:upper:] [:lower:] 2>/dev/null`
  case $d in
     label=*)
       D="/dev/disk/by-label/${D#*=}" #`echo $D | /bin/busybox   cut -f2- -d '='  2>/dev/null`"
     ;;
     devname=*)
       D="/dev/disk/by-name/${D#*=}"  #`echo $D | /bin/busybox   cut -f2- -d '='  2>/dev/null`"
     ;;
     drvname=*)
       D="/dev/disk/by-name/${D#*=}" #`echo $D | /bin/busybox   cut -f2- -d '='  2>/dev/null`"
     ;;
     name=*)
       D="/dev/disk/by-name/${D#*=}"  #`echo $D | /bin/busybox   cut -f2- -d '='  2>/dev/null`"
     ;;
     path=*)
       D="/dev/disk/by-path/${D#*=}"  #`echo $D | /bin/busybox   cut -f2- -d '='  2>/dev/null`"
     ;;
     id=*)
       D="/dev/disk/by-id/${D#*=}" #`echo $D | /bin/busybox   cut -f2- -d '='  2>/dev/null`"
     ;;
     uuid=*)
       D="/dev/disk/by-uuid/${D#*=}" #`echo $D | /bin/busybox   cut -f2- -d '='  2>/dev/null`"
     ;;
     partuuid=*)
       D="/dev/disk/by-partuuid/${D#*=}" #`echo $D | /bin/busybox   cut -f2- -d '='  2>/dev/null`"
     ;;
     #$DISKID=*)
     #  D="/dev/disk/by-id/`echo $D | /bin/busybox   cut -f2- -d '='  2>/dev/null`"
     #;;
  esac
  echo $D
  return 0
}
#
assign_init_variables()
{
  
  evaluate_shellvar_aliases

  
  FROM=`assign_uuidlabel $FROM`
  if [ "$BOOTDEV" != "" ]; then
    BOOTDEV=`assign_uuidlabel $BOOTDEV`
  else
    BOOTDEV=$FROM
  fi
  INITRD=`assign_uuidlabel $INITRD`
  
  #ROOTDEV=`assign_uuidlabel $ROOT`

  DATADEV=`assign_uuidlabel $DATA`

  RESUMEDEV=`assign_uuidlabel $RESUME`

  SWAPDEV=`assign_uuidlabel $SWAP`

  if [ "$SGNFILE" = "" ]; then
      SGNFILE=livecd.sgn
  fi

  #CHANGES=`assign_uuidlabel $CHANGES`

  #AUTOCMD=`echo $AUTOEXEC | /bin/busybox   tr "~" " "`

  INITCMD=$INIT
  export FROM BOOTDEV INITRD ROOTDEV DATADEV RESUMEDEV SWAPDEV INITCMD
  
  
}
#
read_distrofiles()
{
  local SYSDISTRO
  if [ "$SUPPORTED_DISTROS" != "" ]; then
      for SYSDISTRO in "$SUPPORTED_DISTROS"; do
        SYSDISTRO="`echo $SYSDISTRO | /bin/busybox tr -d ' ' 2>/dev/null`"
        if [ -e DISTRO_SPECS.$SYSDISTRO ]; then
          . DISTRO_SPECS.$SYSDISTRO
          echoconsole "$0" "Distribution support for '$SYSDISTRO' loaded....."
          if [ -e $SYSDISTRO.vars ]; then
            . $SYSDISTRO.vars
          else
            echoconsole "$0" "No specific variables for '$SYSDISTRO' read..."
          fi
          if [ -e $SYSDISTRO.functions ]; then
            . $SYSDISTRO.functions
          else
            echoconsole "$0" "No specific functions for '$SYSDISTRO' read..."
          fi
        else
          echoconsole "$0" "Distribution '$SYSDISTRO' not supported, "
          echoconsole "$0" "or no special support necessary. Continuing without..."
        fi
      done
      return 0
  else
    echoconsole "$0" "No special distribution support enabled!"
    return 1
  fi
}
#
probe_for_kernelmodule_squashfs()
{
   # probe for a squashfs archive with kernel modules and mount if possible
   
  local FSYS  SIZE
  FSYS=""
  # are the required file systems compiled into kernel or modules already loaded?
  #FSYS="`/bin/busybox grep squashfs /proc/filesystems 2>/dev/null`"
  #if [ "$FSYS" = "" ]; then
  if `is_not_string_in_file "squashfs" "/proc/filesystems" `; then
    echoconsole "$INITPREF" "no squashfs compiled in kernel '$KERNVER'"      
    echoconsole "$INITPREF" "or no kernel module squashfs loaded"      
    echoconsole "$INITPREF" "continuing without kernel modules from a squashfs...."      
    return 3
  fi
   
  if [ "$SQUASHFSEXT" = "" ]; then SQUASHFSEXT="sfs"; fi   
  export SQUASHFSEXT
  assign_kernver_signed_file "/" "$SQUASHFSEXT"
  
  if [ "$KERNVERFILE" != "" ]; then
    KERNELFILE="$KERNVERFILE"
  else
    echoconsole "$INITPREF" "no squashfs file with kernel modules found"      
    echoconsole "$INITPREF" "continuing without modules in a squashfs...."      
    return 4
    #FSYS="`/bin/busybox grep autofs /proc/filesystems 2>/dev/null`"  
  fi
  # prepare for overlaying kernel modules to target system
  if [ "$OVERLAY" != "" ]; then
    echoconsole "$INITPREF" "Preparing for layerfs (aufs, unionfs, overlayfs) use ......"
    MODTMPDIR="$DEFAULT_MODTMPDIR"
    SIZE=0
    if [ "$MODTMPDIR" = "" ]; then MODTMPDIR="/tmp/modtmpfs"; fi
    export MODTMPDIR
    #/bin/busybox mkdir -p  $MODTMPDIR  2>/dev/null
    #SIZE=`/bin/busybox ls -1s $KERNELFILE  2>/dev/null`
    #SIZE=${SIZE%$KERNELFILE}
    # size in bytes
    #SIZE=$(( $SIZE * 1024 ))
    # add 5% of security buffer
    #SIZE=$(( $SIZE + 5 * $SIZE / 100 ))
    #/bin/busybox mount -n -t tmpfs -o size=$SIZE  tmpfs  $MODTMPDIR  2>/dev/null
    #/bin/busybox mv -f $KERNELFILE  $MODTMPDIR/  2>/dev/null
    #assign_kernver_signed_file "$MODTMPDIR" "$SQUASHFSEXT" 
    #KERNELFILE="$KERNVERFILE"
    echoconsole "$INITPREF" "......prepared for layerfs:"
    echoconsole "$INITPREF" "modules file '$KERNELFILE' at '$MODTMPDIR'"
  fi
  export KERNELFILE
  # install modules at standard place
  /bin/busybox mkdir -p /lib 2>/dev/null
  /bin/busybox mkdir -p /lib/modules 2>/dev/null
  /bin/busybox mkdir -p /lib/modules/$KERNVER 2>/dev/null
  /bin/busybox mkdir -p /lib/modules/$KERNVER/kernel 2>/dev/null
  # you definitely need compiled into kernel : 
  # squashfs with compression support, loop device support,  to mount successfully 
  /bin/busybox mount -t squashfs -o loop,ro   $KERNELFILE  /lib/modules/$KERNVER/kernel 2>/dev/null
  RC=$?
  /bin/busybox sync  2>/dev/null
  echoconsole "$INITPREF" "Mounted '$KERNELFILE' with '$RC' "
  LOCAL_DRIVERS=""
  if [ -e /lib/modules/$KERNVER/kernel/drivers ]; then
    echoconsole "$INITPREF" "Directory for kernelmodules found at /lib/modules/$KERNVER/kernel/drivers"
    LOCAL_DRIVERS="yes"
  else
    # TODO: for now I don't know how to run unsquashfs in initramfs without lots of libraries and squashfs compiled in 
    unsquashfs "$KERNELFILE" 2>/dev/null
    #RC=$?
    /bin/busybox sync  2>/dev/null
    #/bin/busybox rm  $KERNELFILE  2>/dev/null
    echoconsole "$INITPREF" " unsquashfs '$KERNELFILE' ended with '$RC' "
    if [ -e squashfs-root ]; then
     /bin/busybox mv -f squashfs-root/*  /lib/modules/$KERNVER/kernel/  2>/dev/null
     /bin/busybox rm -Rf squashfs-root  2>/dev/null
    elif [ -e $MODTMPDIR/squashfs-root ]; then
     /bin/busybox mv -f $MODTMPDIR/squashfs-root/*  /lib/modules/$KERNVER/kernel/  2>/dev/null
     /bin/busybox rm -Rf $MODTMPDIR/squashfs-root  2>/dev/null
    else
      echoconsole "$INITPREF" "Failed to extract kernelmodules in '$KERNELFILE' with 'unsquashfs'!"
    fi
  fi
  export LOCAL_DRIVERS
  /bin/busybox sync  2>/dev/null
  if  ! [  -e  /lib/modules/$KERNVER/kernel/drivers ]; then
    echoconsole "$INITPREF" "Failed to install kernelmodules '$KERNELFILES' at /lib/modules/$KERNVER/kernel !"
  fi
 #set +x

}
#
probe_for_kernelmodule_tarball()
{
  local LIBMODFILES LIBMODF
  LIBMODFILES=""
  LIBMODF=""
  # do not overwrite already mounted kernel module file or existent kernel modules
  if [ "`/bin/busybox ls -1 /lib/modules/$KERNVER/kernel  2>/dev/null`" = "" ]; then
    assign_kernver_signed_file "/" "tar.*"
	  if [ "$KERNVERFILE" != "" ]; then
      LIBMODF="$KERNVERFILE"
    else
      assign_kernver_signed_file "/" "tar.*" "libmodules"
      if [ "$KERNVERFILE" != "" ]; then
        LIBMODF="$KERNVERFILE"
      fi
    fi
    if [ "$LIBMODF" = "" ]; then
      LIBMDOFILES="libmodules*.tar.*"
      LIBMODFILES=`/bin/busybox ls -1 "$LIBMODFILES"  2>/dev/null`
      LIBMODF="libmodules-$KERNVER.tar.*"
      LIBMODF=`/bin/busybox ls -1 $LIBMODF   2>/dev/null`
    fi
    
  fi
  # make the following scripts for module loading runnable - if we need some drivers..... 
  if [ "$LIBMODF" = "" ]; then
    # more than one and no current kernelversion in: take only the first one
    LIBMODF="$(echo $LIBMODFILES | /bin/busybox tr "\n" " " 2>/dev/null | /bin/busybox cut -f1 -d ' ' 2>/dev/null)"
  fi 
  if [ "$LIBMODF" != "" ]; then
    export LIBMODF
    if [ -e "$LIBMODF" ]; then
      KERNELFILE="$LIBMODF"
      echoconsole  "$INITPREF" "extracting kernel modules from '$LIBMODF' ..."
      /bin/busybox tar -xf  $LIBMODF   2>/dev/null
      RC=$?
      /bin/busybox sync
      # clean up unused kernelmodules for other kernelversions
      #purge_unused_kernelmodules  "" "$INITPREF"    
      [ $RC -eq 0 ] && echoconsole  "$INITPREF" ".....done.  Continuing boot with these modules...."
      [ $RC -ne 0 ] && echoconsole  "$INITPREF" " Error! Extraction ended with '$RC' !"
      if [ -e /lib/modules/$KERNVER/kernel/drivers ]; then
        echoconsole "$INITPREF" "Directory for kernelmodules found at '/lib/modules/$KERNVER/kernel/' "
        export LOCAL_DRIVERS="yes"
      else
        echoconsole "$INITPREF" "Directory for kernelmodules not found! Continuing..."
      fi
    else
      echoconsole  "$INITPREF" " File '$LIBMODF' does not exist ! "
    fi
  else
    echoconsole  "$INITPREF" " No modules extracted, no file '$KERNVERFILE' found  !"
  fi
}
#
is_not_up_rootdevice_old()
{
  #set -x
  local DEVTREE RDEV SYSBLK rootdev sysblkdev sysdev dev PART
  rootdev=""
  sysblkdev=""
  sysdev=""
  #DEVTREE=`/bin/busybox ls -1 /dev/sd* /dev/hd* /dev/sr* /dev/mmcblk* 2>/dev/null`
  #SYSBLK=`/bin/busybox ls -1 /sys/block/sd* /sys/block/hd* /sys/block/sr* /sys/block/mmcblk* 2>/dev/null`
  
  sysblkdev=${ROOTDEV#/dev/}
  sysblkdev=$(echo $sysblkdev | /bin/busybox tr -d [:alpha:] 2>/dev/null)
  sysblkdev=${ROOTDEV//$sysblkdev}
  sysblkdev=${sysblkdev#/dev/}
  dev=""
  for dev in `/bin/busybox ls -1d /sys/block/sd* 2>/dev/null` `/bin/busybox ls -1d /sys/block/hd* 2>/dev/null` `/bin/busybox ls -1d /sys/block/mmcblk* 2>/dev/null` ; do
    dev=${dev#/sys/block/}
    if [ "$dev" = "$sysblkdev" ]; then
      sysdev=found
      break
    fi
  done
  dev=""
  for dev in `/bin/busybox ls -1 /dev/sd* 2>/dev/null` `/bin/busybox ls -1 /dev/hd* 2>/dev/null` `/bin/busybox ls -1 /dev/sr* 2>/dev/null` `/bin/busybox ls -1 /dev/mmcblk*  2>/dev/null` ; do
    if [ "$ROOTDEV" = "$dev" ]; then
      rootdev=found
      break
    fi
  done
  PART=""
  RC=5
  if [ "$sysdev" != "" -a "$rootdev" != ""  ]; then
    # can I read the PARTUUID from the required rootdevice?
    PART=`/bin/busybox dd if=/dev/$sysblkdev  bs=1 count=4  skip=440 2>/dev/null | /bin/busybox hexdump  2>/dev/null | /bin/busybox tr "\n" " " 2>/dev/null`
    RC=$?
    if [ "$PART" != "" ]; then 
      if [ $RC -eq 0 ]; then
         PUUID=""
         # reorder the words containing the partuuid 
         BYTE1=`echo $PART | /bin/busybox cut -f3 -d" " 2>/dev/null`
         BYTE2=`echo $PART | /bin/busybox cut -f2 -d" " 2>/dev/null`
         PUUID="$BYTE1$BYTE2"
         if [ "$PUUID" != "" ]; then 
           if [ "$DISKUUID" = "" ]; then
             export DISKUUID="$PUUID"
           else
             if [ "$PUUID" != "$DISKUUID" ]; then
               echofile "$INITPREF" "Warning: Found a difference in PARTUUIDs:"
               echofile "$INITPREF" "Detected PartitionUUID '$PUUID' and the DiskUUID '$DISKUUID' found before differ!"
               echofile "$INITPREF" "This may cause boot partition failure !"
             fi
           fi
           if [ "PARTUUID" = "" ]; then
             PARTUUID="$PUUID-0"
             PARTUUID=${PARTUUID}${ROOTDEV#/dev/$sysblkdev}
             export PARTUUID
           fi
         fi
         return 1
      else
        return 0
      fi
    else
      return 0
    fi
  else 
    return 0
  fi
  
}

# checks loop and ram devices as well!
is_not_up_blockdevice()
{
  
  local DEVTREE RDEV SYSBLK rootdev sysblkdev sysdev dev PART
  rootdev=""
  sysblkdev=""
  sysdev=""
  RDEV=""
  if [ "$1" != "" ]; then
    RDEV="$1"
  else
    return 127
  fi  
  sysblkdev=${RDEV#/dev/}
  sysblkdev=$(echo $sysblkdev | /bin/busybox tr -d [:alpha:] 2>/dev/null)
  sysblkdev=${RDEV//$sysblkdev}
  sysblkdev=${sysblkdev#/dev/}
  dev=""
  SYSBLK=""
  SYSBLK=$(/bin/busybox ls -1d /sys/block/* 2>/dev/null)
  for dev in $SYSBLK ; do
    dev=${dev#/sys/block/}
    if [ "$dev" = "$sysblkdev" ]; then
      sysdev=found
      if [ "$(/bin/busybox ls -1 "$RDEV" 2>/dev/null)" = "$RDEV" ]; then
       rootdev=found
      fi
    fi
    if [ "$sysdev" = "found" -a "$rootdev" = "found"  ]; then break; fi
  done
  PART=""
  RC=5
  if [ "$sysdev" != "" -a "$rootdev" != ""  ]; then
    # can I read the PARTUUID from the required rootdevice?
    PART=$(/bin/busybox dd if=/dev/$sysblkdev  bs=1 count=4  skip=440 2>/dev/null | /bin/busybox hexdump  2>/dev/null)
    RC=$?
    if [ "$PART" != "" ]; then 
      if [ $RC -eq 0 ]; then
         PUUID=""
         # reorder the words containing the partuuid 
         BYTE1=${PART:8:4}
         BYTE2=${PART:13:4}
         PUUID="$BYTE2$BYTE1"
         if [ "$PUUID" != "" ]; then 
           export DISKUUID="$PUUID"
           if [ "$2" = "setpartuuid" ]; then
             PARTUUID="$PUUID-0"
             PARTUUID=${PARTUUID}${RDEV#/dev/$sysblkdev}
             export PARTUUID
           fi
         else
           echoconsole "$INITPREF" "Warning: Error in assigning PartitionUUID " 
         fi
         return 1
      else
        return 0
      fi
    else
      return 0
    fi
  else 
    return 0
  fi
}
#
is_not_up_rootdevice()
{
  # does export PARTUUID and DISKUUID !
  if `is_not_up_blockdevice "$ROOTDEV" setpartuuid`; then
    return 0
  else
    return 1
  fi
}
#
is_not_up_bootdevice()
{
  # does not export PARTUUID and DISKUUID !
  if `is_not_up_blockdevice "$BOOTDEV"`; then
    return 0
  else
    return 1
  fi
}
# under construction
wait_for_rootdevice()
{
  local TIMEOUT 
  /bin/busybox sleep 2 
  return 0
}
#
parse_rootdevice_string()
{
  # this function only parses in RAM, no contact to devices!!!!!
  #set -x
  local ROOTVAR
  export UUID=""
  export LABEL=""
  export PARTUUID=""
  export DISKID=""
  export PATHID=""
  export DISKUUID=""
  export PARTNUM=""
  ROOTVAR="$(echo $ROOT | /bin/busybox tr [:upper:] [:lower:] 2>/dev/null )"
  if [ "$ROOTVAR" != "" ]; then
    case $ROOTVAR in
      ask|i|interactive)
        ROOTDEV="ask"
        check_dialog_equipment
        branch_2dialog        
      ;;
      # the OpenSuSE cases have to be first......
      /dev/disk/by-*/*)
        # assign UUID/LABEL content
        ROOTDEV=$ROOT
        ROOTVAR=${ROOT#/dev/disk/*/}
        # ROOT=LABEL or UUID  
        ROOT=${ROOT#/*/*/*-}
        # remove / and UUID/LABEL content from $ROOT
        ROOT=${ROOT%/*}  # | /bin/busybox cut -f1 -d "/"    2>/dev/null)"
        eval "ROOT=$ROOT=\"$ROOTVAR\""
        export ROOTDEV ROOT
        parse_rootdevice_string
      ;;
      id=*)
        ROOTVAR=${ROOT#id=}
        DISKID=${ROOTVAR%-part*}
        PARTNUM=${ROOTVAR#$DISKID-part}
        #PARTNUM=${PARTNUM#part}
        if [ "$PARTNUM" != "" ]; then
          ROOTDEV="ID=$DISKID-part$PARTNUM"
        else
          ROOTDEV="ID=$DISKID"
        fi
      ;;
      path=*)
        ROOTVAR=${ROOT#path=}
        PATHID=${ROOTVAR%-part*}
        PARTNUM=${ROOTVAR#$PATHID-part}
        #PARTNUM=${PARTNUM#part}
        if [ "$PARTNUM" != "" ]; then
          ROOTDEV="PATH=$PATHID-part$PARTNUM"
        else
          ROOTDEV="PATH=$PATHID"
        fi
      ;;
    # any information for root device specified in fields with separator ':'?
      *:*:*)
        ROOT=${ROOT%:*}
        ROOTFS=${ROOTVAR%:*}
        ROOTFS=${ROOTVAR#$ROOTFS:}
        export ROOT ROOTFS
        parse_rootdevice_string
      ;;
      *:*)
        ROOT=${ROOT//:*}
        ROOTFSTYPE=${ROOTVAR#*:}
        export ROOT ROOTFSTYPE
        parse_rootdevice_string
      ;;
      # the Slackware, Puppylinux, .... cases
      /dev/hd*|/dev/sd*|/dev/sr*|/dev/mmcblk*|/dev/cdrom*|/dev/dvdrom*|/dev/cdram*|/dev/dvdram*|/dev/scd*)
        ROOTDEV=${ROOTVAR}
        PARTNUM=$(echo $ROOTDEV | /bin/busybox tr -d [:alpha:] 2>/dev/null)
      ;;
      hd*|sd*|sr*|mmcblk*|scd*|cdrom*|dvdrom*|cdram*|dvdram*)
        ROOTDEV="/dev/$ROOTVAR"
        PARTNUM=$(echo $ROOTDEV | /bin/busybox tr -d [:alpha:] 2>/dev/null)
      ;;
      # the Redhat, Ubuntu,..., and generic cases
      label=*=uuid=*)
        LABEL=${ROOT#*=}
        #LABEL=${LABEL//=*} # 
        UUID=${LABEL#*=*=}   #  "$(echo $ROOT | /bin/busybox cut -f3  -d "="    2>/dev/null)"
        LABEL=${LABEL//=*}    # "$(echo $LABEL| /bin/busybox cut -f2  -d "="    2>/dev/null)"
        ROOTDEV="UUID=$UUID"
      ;;
      label=*,uuid=*)
        #LABEL="$(echo $ROOT | /bin/busybox cut -f2  -d "="    2>/dev/null| /bin/busybox cut -f1  -d ","    2>/dev/null)"
        #UUID="$(echo $ROOT  | /bin/busybox cut -f2-  -d ","    2>/dev/null | /bin/busybox cut -f1  -d "="    2>/dev/null)"
        UUID=${ROOT#*=*,*=}
        LABEL=${ROOT//,*}
        LABEL=${LABEL#*=}
        ROOTDEV="UUID=$UUID"
      ;;
      uuid=*=label=*)
        UUID=${ROOT#*=}
        LABEL=${UUID#*=*=}
        UUID=${UUID//=*}
        ROOTDEV="UUID=$UUID"
      ;;
      uuid=*,label=*)
        LABEL=${ROOT#uuid=*,label=}
        UUID=${ROOT//,*}
        UUID=${UUID#uuid=}
        ROOTDEV="UUID=$UUID"
      ;;
      label=*)
         LABEL=${ROOT#*=} 
         ROOTDEV="LABEL=$LABEL"
      ;;
      uuid=*)
        UUID=${ROOT#*=}
         ROOTDEV="UUID=$UUID"
      ;;
      partuuid=*)
        PARTUUID=${ROOT#*=}
        # cut out the characters after last "-" in string  
        UUID=${PARTUUID//*-}
        DISKUUID=${PARTUUID//-*}
        # allow maximal 0x16 (=22 decimal) partititons for PARTUUID, else switch to UUID interpretation
        if [ $(( 0x$UUID )) -ge 1 -a $(( 0x$UUID )) -le 22 ]; then  
          PARTNUM=$(( $UUID )) 
        else
          UUID=$PARTUUID
          PARTNUM=""
        fi
        ROOTDEV="PARTUUID=$PARTUUID"
      ;;
      # is there a shell variable specified before rootdevice's label or uuid declaration?
      *=label=*|*=uuid=*|*=partuuid=*)
        # assign the variable before the uuid/label spec and reparse
        ROOTVAR="$(echo ${ROOT//=*} | /bin/busybox tr [:lower:]  [:upper:]  2>/dev/null | /bin/busybox tr ".-" "_"  2>/dev/null)"
        ROOT=${ROOT#*=}
        eval "$ROOTVAR=\"$ROOT\"" 
        export $ROOTVAR
        if [ "$ROOT" != "" ]; then
          export ROOT
          parse_rootdevice_string
        fi
      ;;
    esac

    export  ROOTDEV LABEL UUID PARTUUID DISKID PATHID DISKUUID PARTNUM

  fi
  
}
#
# version 0.00001 RC
recognize_rootdevice()
{
  local var cnt BLKID DEVNUM THEDEV DEVBOOT DEVROOT DEVROOT1 DEVROOT2
  var=""
  BLKID=""
  DEVBOOT=""
  DEVROOT=""
  DEVROOT1=""
  DEVROOT2=""

  if [ "$ROOTDEV" != "" ]; then
    # ROOTDEV must have the LABEL= UUID= PARTUUID= specification  
    DEVROOT=`/bin/busybox findfs "$ROOTDEV" 2>/dev/null`
    if [ "$DEVROOT" != "" ]; then
      export ROOTDEV="$DEVROOT"
    else
      if [ "$PARTUUID" != "" ]; then
        DEVROOT=`get_blockdev_from_partuuid  "$PARTUUID"`
        if [ "$DEVROOT" != "" ]; then
          export ROOTDEV="$DEVROOT"
        fi        
      fi
      if [ "$DISKID" != "" ]; then
        DEVROOT=`get_blockdev_from_diskid  "$DISKID"`
        if [ "$DEVROOT" != "" ]; then
          export ROOTDEV="$DEVROOT"
        fi                
      fi
      if [ "$PATHID" != "" ]; then
        DEVROOT=`get_blockdev_from_pathid  "$PATHID"`
        if [ "$DEVROOT" != "" ]; then
          export ROOTDEV="$DEVROOT"
        fi                
      fi
    fi
    if [ "$DEVROOT" = "" ]; then
      if [ "$LABEL" != "" ]; then
        DEVROOT1=`/bin/busybox findfs "LABEL=$LABEL" 2>/dev/null`
      fi
      if [ "$UUID" != "" ]; then
        DEVROOT2=`/bin/busybox findfs "UUID=$UUID" 2>/dev/null`
      fi
      if [ "$DEVROOT1" != "" -o "$DEVROOT2" != "" ]; then
        if [ "$DEVROOT1" != "$DEVROOT2" ]; then
          echoconsole "$INITPREF"  "Warning: Specified UUID and LABEL do not match the same device! "
          [ "$DEVROOT1" != "" ] && DEVROOT="$DEVROOT1" && echoconsole "$INITPREF"  "Warning: Using block device, recognized with LABEL, is not necessarily unique !"        
          [ "$DEVROOT2" != "" ] && DEVROOT="$DEVROOT2" && echoconsole "$INITPREF"  "Warning: Preferring to use the UUID specified device before LABEL !"        
        else
          DEVROOT="$DEVROOT2"
          export ROOTDEV="$DEVROOT"          
        fi
      fi
    fi
    if [ "$DEVROOT" = "" ]; then
      BLKID=`/bin/busybox blkid 2>/dev/null`
      DEVROOT=`echo "$BLKID" | /bin/busybox grep "UUID=\"$UUID\"" 2>/dev/null`
      if [ "$DEVROOT" != "" ]; then        
        for var in $DEVROOT; do
          case $var in
            *=*)
              eval "$var"
              export $var
            ;;
            /*/*:)
              DEVBOOT=${var%:}
            ;;
          esac
        done
        if [ "$TYPE" != "" ]; then
           ROOTDEVTYPE="$TYPE"
        fi
        [ "$DEVBOOT" != "" ]  && export ROOTDEV="$DEVBOOT"
      else 
        DEVROOT=`echo "$BLKID" | /bin/busybox grep "LABEL=\"$LABEL\"" 2>/dev/null `
        if [ "$DEVROOT" != "" ]; then        
          for var in $DEVROOT; do
            case $var in
              *=*)
                eval "$var"
              ;;
              /*/*:)
                DEVBOOT=${var%:}
              ;;
            esac
          done
          if [ "$TYPE" != "" ]; then
             ROOTDEVTYPE="$TYPE"
          fi
          [ "$DEVBOOT" != "" ]  && export ROOTDEV="$DEVBOOT" && echoconsole "$INITPREF" "Warning: Using block device, recognized with LABEL, is not necessarily unique !"
        fi
      fi
      export ROOTDEVTYPE UUID LABEL 
    fi
    return 0
  else # rootdev=""
     return 5
  fi  # rootdev
  
}
#
verify_rootdevice()
{
  local var BLKID DEVBOOT DEVROOT DEVROOT1 DEVROOT2
  if [ -e $ROOTDEV ]; then
    if [ "$ROOTDEV" = "$ROOT" ]; then
      if [ "$LABEL" = "" ]; then
        :
      fi
      if [ "$UUID" = "" ]; then
        :
      fi
      if [ "$PARTUUID" = "" ]; then
        PARTUUID=`get_partuuid_from_blockdev  $ROOTDEV 2>/dev/null`
      fi
    else
      :
    fi
    return 0
  fi
  set_disk_parameters
  parse_rootdevice_string
  recognize_rootdevice
  return 1
}
#
recognize_rootdevice_old()
{
    if [ "$ROOTDEV" != "" ]; then
      [ "$LABEL" != "" ] && DEVROOT1=`/bin/busybox findfs "LABEL=$LABEL" 2>/dev/null`
      [ "$UUID" != "" ]  && DEVROOT2=`/bin/busybox findfs "UUID=$UUID" 2>/dev/null`
    
      TYPE=""
      if [ "$DEVROOT1" != "$DEVROOT2" ]; then
        [ "$DEVROOT2" != "" ] && DEVROOT="$DEVROOT2"
        [ "$DEVROOT1" != "" ] && DEVROOT="$DEVROOT1"
      else
        DEVROOT="$DEVROOT1"
        export ROOTDEV="$DEVROOT"        
      fi

    if [ "$LABEL" != "" -o "$UUID" != "" ]; then
      DEVROOT2=""
      DEVROOT1=""
      if [ "$LABEL" != "" ]; then
        DEVROOT1=`/bin/busybox findfs "LABEL=$LABEL" 2>/dev/null`
      fi
      if [ "$UUID" != "" ]; then
        DEVROOT2=`/bin/busybox findfs "UUID=$UUID" 2>/dev/null`
      fi
      TYPE=""
      if [ "$DEVROOT" != "$DEVROOT2" ]; then
        [ "$DEVROOT2" != "" ] && DEVROOT="$DEVROOT2"
        [ "$DEVROOT1" != "" ] && DEVROOT="$DEVROOT1"
      else
        DEVROOT="$DEVROOT1"
        export ROOTDEV="$DEVROOT"        
      fi
    fi # label, uuid
    if [ "$NOAUTOFS" != "" ]; then 
      BLKID=`/bin/busybox blkid 2>/dev/null`
      DEVBOOT=`echo "$BLKID" | /bin/busybox grep "$ROOTDEV" 2>/dev/null`
      TYPE=""
      for var in $DEVBOOT; do
        case $var in
          *=*)
            eval "$var"
          ;;
          /*/*:)
            DEVROOT=${var//:*}
          ;;
        esac
      done
      if [ "$TYPE" != "" ]; then
         export ROOTDEVTYPE="$TYPE"
      fi 
      [ "$BLKID" != "" ] || BLKID=`/bin/busybox blkid 2>/dev/null`
      DEVROOT=`echo "$BLKID" | /bin/busybox grep "UUID=\"$UUID\"" 2>/dev/null `
      if [ "$DEVROOT" != "" ]; then        
        for var in $DEVROOT; do
          case $var in
            *=*)
              eval "$var"
            ;;
            /*/*:)
              DEVBOOT=${var//:*}
            ;;
          esac
        done
        if [ "$TYPE" != "" ]; then
           export ROOTDEVTYPE="$TYPE"
        fi
      else 
        ROOTDEV="" 
        LABEL=""
        UUID=""
        ROOTDEVTYPE=""
        export ROOTDEVTYPE UUID LABEL
      fi
    
      if [ "$DEVBOOT" != "" ]; then
        export ROOTDEV="$DEVBOOT"
      else
        export ROOTDEV
      fi
      return 0
    fi # noautofs
  else  # rootdev
    return 255
  fi  #rootdev
  
  if [ "$BOOT" != "" ]; then
   return 0
  else
   return 0
  fi
    
}
#
# under construction
check_dialog_equipment()
{
  return 0
}
#
# under construction
branch2_dialog()
{
  return 0
}
#
echoconsole "[ initsys-functions ]:" "read in!"    
#

