#
#  INIT-FUNCTIONS for YaIniT Yet an almost universal INIT Tool with busybox
#  (C) Dieter Miosga , 2008-2016-01-01
#
#echo   "[ initrd-functions ]: Being read in...."
# read in necessary functions
#
check_for_branch()
{
  #set -x
  local BRANCHPARM BRANCHTO
  BRANCHPARM=""
  BRANCHTO=""
  if [ "$BASENM" != ""  ]; then
    case "$BASENM" in
      ram)
        echoconsole  "$1" " branching to YaIniT Live-Setup in RAM ...."
        /bin/busybox sync
        BRANCHTO=ram
      ;;
      loop)
        echoconsole  "$1" " continuing YaIniT for boot to loop blockdevice '$ROOTDEV' ..."
        /bin/busybox sync
        BRANCHTO=loop      
      ;;
      net)
        echoconsole  "$1" " continuing YaIniT for boot to net blockdevice '$ROOTDEV' ..."
        /bin/busybox sync
        BRANCHTO=net
      ;;
      *)
      ;;
    esac
    BRANCHPARM="branch-$BRANCHTO"
    if [ "$BRANCHPARM" != "branch-" ]; then
      /bin/busybox cp init initrc  2>/dev/null
      export PHASE OLDINITPARAMETERS="$INITPARAMETERS"  
      echoconsole  "$1" " .... now!"
      exec /initrc "branchparm=$BRANCHPARM" "$ARCH" "$BRANCHTO"
    else
      echoconsole  "$1" "'$ROOTDEV' : inadmissible parameter for branching out ..."
    fi
  else
    echoconsole  "$1" "'$ROOTDEV' : continuing, no parameter found for booting into RAM..."
  fi

}
#
check_for_ramboot_branch()
{
  #set -x
  local BRANCHTO BRANCHPARM
  if [ "$BASENM" != ""  ]; then
    #
    BRANCHPARM=""
    case "$BASENM" in
      ram)
        echoconsole  "$1" " branching to YaIniT Live-Setup in RAM ...."
        /bin/busybox sync
        BRANCHTO=ram
        BRANCHPARM="branch-$BRANCHTO"
      ;;
      loop)
        echoconsole  "$1" " continuing YaIniT for boot to blockdevice '$ROOTDEV' ..."
        /bin/busybox sync
        BRANCHTO=loop      
        BRANCHPARM="branch-$BRANCHTO"
      ;;
      net)
        echoconsole  "$1" " continuing YaIniT for boot to network based device '$ROOTDEV' ..."
        /bin/busybox sync
        BRANCHTO=net
        BRANCHPARM="branch-$BRANCHTO"
      ;;
      *)
        BRANCHTO="$BASENM"
      ;;
    esac
    if [ "$BRANCHPARM" != "" ]; then
      if [ -e $BRANCHPARM-functions ]; then
        /bin/busybox sync
        if [ "$INITDBG" != "" -o  "$DEBUG" != "" ]; then
          debug_prompt "$1"
        fi
        /bin/busybox cp init initrc  
        export OLDINITPARAMETERS="$INITPARAMETERS"  PHASE
        echoconsole  "$1" "... now! "
        exec /initrc "$BRANCHPARM" "$ARCH" "$BRANCHTO"
      else
        echoconsole  "$1" " no $BRANCHPARM-functions library found for branching out with '$BRANCHTO' !"
        echoconsole  "$1" " continuing..."
      fi
    else
       echoconsole  "$1" " parameter '$BRANCHPARM' invalid to branch !"
       echoconsole  "$1" " continuing regular boot like for a blockdevice ..."
    fi
  else
    echoconsole  "$1" " no parameter found for branching out !"
    echoconsole  "$1" " continuing regular boot like for a blockdevice ..."    
  fi
}
#
branch_2ram()
{
   if [ -e linuxrc-live  ]; then
     echoconsole  "$1" " branching to 'linuxrc-live' now for boot...."
     /bin/busybox sync
     #/bin/busybox ln -sf /dummy.sh /etc/init.d/rcS
     if [ "$INITDBG" != "" -o  "$DEBUG" != "" ]; then
       debug_prompt "$1"
     fi
     export OLDINITPARAMETERS="$INITPARAMETERS"
     exec /linuxrc-live $ARCH
   else
     echoconsole  "$1" " no linuxrc-live script found for boot into ramfs.."
   fi
   error2ash "$1"
   exit 1
}
#
branch_2disk()
{
  if [ -e linuxrc ]; then
     echoconsole  "$1" " branching to 'linuxrc' now for boot..."
     /bin/busybox sync
     #/bin/busybox ln -sf /dummy.sh /etc/init.d/rcS
     if [ "$INITDBG" != "" ]; then
       debug_prompt "$1"
     fi
     export OLDINITPARAMETERS="$INITPARAMETERS"
     /bin/busybox cp init initrc
     exec /linuxrc "$ARCH"
  else
   echoconsole  "$1" " no linuxrc script found for local boot.."
  fi
  error2ash "$1"
  exit 1
}
#
branch_2blockdev()
{
  if [ -e branch-block-functions ]; then
     echoconsole  "$1" " branching to 'devblockrc' now for boot..."
     /bin/busybox sync
     #/bin/busybox ln -sf /dummy.sh /etc/init.d/rcS
     /bin/busybox cp init initrc
     if [ "$INITDBG" != "" ]; then
       echoconsole "$INITPREF" "we branch out with '$ARCH' '$BASENM'"
       debug_prompt "$1"
     fi
     export PHASE OLDINITPARAMETERS="$INITPARAMETERS" 
     exec /initrc "branchparm=branch-block" "$ARCH" ""
  else
     echoconsole  "$1" " no branch-block-functions script found for boot to block device '$ROOTDEV' .."
  fi
  echoconsole  "$1" " system crashes after prompting you. Please correct your YaIniT scripts setup!"
  error2ash "$1"
  exit 1
}
#
branch_2blockdev_new()
{
  local BRANCHTO BRANCHPARM
  BRANCHTO="" 
  BRANCHPARM=""
  case "$BASENM" in
    sd|hd|mmcblk)
      echoconsole  "$1" " branching to YaIniT Live-Setup now...."
      /bin/busybox sync
      BRANCHTO=block
      BRANCHPARM="branch-$BRANCHTO"
    ;;
    *)
      BRANCHPARM=direct
      BRANCHTO="$BASENM"
    ;;
  esac
  if [ -e $BRANCHPARM-functions ]; then
   echoconsole  "$1" " branching to 'devblockrc' now for boot..."
   /bin/busybox sync
   #/bin/busybox ln -sf /dummy.sh /etc/init.d/rcS
   /bin/busybox cp init initrc
   if [ "$INITDBG" != "" ]; then
     echoconsole "$INITPREF" "we branch out with '$ARCH' '$BASENM'"
     debug_prompt "$1"
   fi
   OLDINITPARAMETERS="$INITPARAMETERS"
   export OLDINITPARAMETERS
   exec /initrc "$BRANCHPARM" "$ARCH" "$BRANCHTO"
  else
   echoconsole  "$1" " no branch-$BRANCHTO-functions script found for local boot.."
  fi
  error2ash "$1"
  exit 1
}
#
branch_out()
{
   #set -x
 
    if [ "$BASENM" != "ram" ]; then
    {
      branch_2blockdev "$1" "$2"
    }
    else
    {
      branch_2ram "$1" "$2"
    }
    fi

}
#
setup_configurations()
{
  #
  #   PHASE 1
  #   1. read in basic system variables and parameters
  #   2. read in system architecture parameters
  #   2. build root filesytem tree
  #   3. mount initial filesystems and assign variables
  #   4. assign root device and set variables appropriately
  #
  # now is the functionality in initrd-functions fully usable
  inline_external_file "yainitdefaults"

  echofile  "$INITPREF"  " Building directory tree for initramfs...... "

  build_rootfs    2>/dev/null
  /bin/busybox sync

  echofile  "$INITPREF" "......done."

  #echoconsole  "$INITPREF" " Starting regular boot:"
  echofile   "$INITPREF" " Mount system directories amd make initramfs usable........ "
  ECHOTEXT=""
  inline_external_file  "filesys-functions"
  mount_filesystems     "$INITPREF"
  echoconsole "" "$ECHOTEXT"

  /bin/busybox sync
  create_rootfs_dirs ""
  export PATH=/:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:/lib
  #/bin/busybox mount  -o remount,rw /         2>/dev/null   # for the case we forgot rw in initramfs
  /bin/busybox ln -s /proc/mounts /etc/mtab  2>/dev/null

  set_kernver          "$INITPREF"
  assign_kernver_vars  "$INITPREF"
  echofile "$INITPREF" "Booting with kernel $TOPKERNVER.$MAJORKERNVER.$MINORKERNVER"
  echofile "$INITPREF" "with custom specification '$EXTRAKERNVER'"
  echofile "$INITPREF" "and optimization index '$SUFFIXKERNVER'"
  # verify parameter root=.... is given from kernel command line and read it
  # do this now in a very tricky memory saving way
  # thanks to the insights prepared by Barry Kauler with his Puppylinux Distribution.
  # The for-case loop can be reduced to the detection of a few unary boot parameters
  # and all parameter variables are generated dynamically without great need of predefinition

  echofile  "$INITPREF" "Assign boot parameters to variables....... "
  # initialize distribution specific variables as NULL
  set_shellvariables
  # now assign all the variables form kernel parameter cmdline
  read_cmdline
  # this is for now temporary, until we boot into RAM from initramdisk
  if [ "$NOCD" = "nocd" -a "$NOUSB" = "nousb" -a "$NOPCMCIA" = "nocpmcia" -a "$NONET" = "nonet" -a "$NOHD" = "nohd" -a "$NOFW" = "nofw" ]; then
     echoconsole "$INITPREF" "you selected boot parameters $NOHD $NOCD $NOUSB $NOPCMCIA $NONET $NOFW "
     echoconsole "$INITPREF" "and blocked therewith any further booting!"
     SYSERRPROMPT=yes
     error2ash   "$INITPREF"
  fi
  
  assign_init_variables
  parse_rootdevice_string
  
  [ "$INITDBG" != "" ] && export >> "$MSGFILE"
  if [ "$VERBOSE" != "" ]; then
    /bin/busybox cat "$MSGFILE"  2>/dev/null
  fi
  # are there any distribution specifics?
  if [ "$DISTRO" != "" ]; then
    SUPPORTED_DISTROS="$DISTRO"
    read_distrofiles
  else
    SUPPORTED_DISTROS="`/bin/busybox ls -1 DISTRO_SPECS.* 2>/dev/null | /bin/busybox tr "\n" " " 2>/dev/null`"
    DISTROS=""
    for SYSDISTRO in "$SUPPORTED_DISTROS"; do
      DISTROS="$DISTROS `echo $SYSDISTRO | /bin/busybox tr -d ' ' | /bin/busybox cut -f2- -d '.' 2>/dev/null`"
    done
    SUPPORTED_DISTROS="$DISTROS"
    if [ "`echo $SUPPORTED_DISTROS | /bin/busybox tr -d ' ' 2>/dev/null `"  != "" ]; then
      read_distrofiles
    fi
  fi

  echoconsole "$INITPREF" "Initial boot parameters from kernel cmdline read........ "

  BASENM=""
  if [ "$ROOTDEV" != "" ]; then
    BASENM="`/bin/busybox basename $ROOTDEV 2>/dev/null | /bin/busybox tr [:upper:] [:lower:]  2>/dev/null |  /bin/busybox tr -d [:digit:]  2>/dev/null`"
    #ROOT=$ROOTDEV
    export BASENM ROOTDEV
  fi

}
#
setup_architecture_specifics()
{

  echoconsole "$INITPREF" "  --> where to boot to: $ROOTDEV"

  inline_external_file "archvarfile"
  # arch-functions are not mandatory, we might continue if none
  if [ -e $ARCH-functions ]; then

   . $ARCH-functions
   # and optimize for cpu architecture
   #set -x
   set_cpuvars "$INITPREF"
   #  set +x
   # conditionally explode the compressed busybox and system files archive
   /bin/busybox sync
   if [ "$NOAUTO" = "" ]; then

     RTFILES="$(/bin/busybox ls -1 rt.tar.* 2>/dev/null)"
     #  extract all compressed system files necessary for live boot if any....
     if [ "$RTFILES" != "" ]; then
       /bin/busybox cp -f /bin/busybox /bin/busybox_out  2>/dev/null
       echoconsole  "$INITPREF" " extracting the '$RTFILES' file with necessary binaries for further boot..."
       # extract unconditionally
       /bin/busybox tar -xf "$RTFILES"  2>/dev/null
       if [ $? -ne 0 ]; then
          echoconsole "$INITPREF" " error in preparing for further boot while extraction of '$RTFILES', reconfigure system!"
          #debug_prompt "$INITPREF"
          echoconsole "$INITPREF" " continuing with default/initial version...."
       else
          /bin/busybox sync
          #/bin/busybox sleep 1
          echoconsole "$INITPREF" ".... Done extraction of cpu-architecture appropriate files!"
          # clean up carefully
          /bin/busybox rm -f rt.tar.* 2>/dev/null
       fi
     fi
     #set -x
     /bin/busybox sync

     # optimize if possible, from extracted or preinstalled executables
     if [ "$(/bin/busybox ls -1 /bin/busybox-*  2>/dev/null)" != "" ]; then
         ECHOTEXT=""
         cmdset_optimize   "$INITPREF" "/bin/busybox"
       echoconsole "" "$ECHOTEXT"
     else
         echoconsole "$INITPREF" " error in optimizing : choosable files, busybox-*  not found!"
     fi

   fi # noauto
   /bin/busybox sync
  
  fi # -e arch-functions

}
#
setup_system()
{
  local RC
  #set -x
  #
  #  PHASE 2
  #  if busybox is optimizable, do it
  #  load kernel modules if any in initramfs and
  #  bring up device filesystem
  #

  setup_architecture_specifics
  /bin/busybox sync

  # clean up unused kernelmodules or too old kernelversions
  purge_unused_kernelmodules  "" "$INITPREF"
  /bin/busybox sync

  if [ "$NOMOD" != "" ]; then
    echoconsole "$INITPREF" "parameter nomod set: "
    echoconsole "$INITPREF" "not loading kernel modules in $THIS ....."
  else

    probe_for_kernelmodule_tarball
    /bin/busybox sync

    if [ "`/bin/busybox ls -1 /lib/modules/$KERNVER/kernel  2>/dev/null`" != "" ]; then      
      # in case the kernelmodule tarball contains some modules necessary to mount 
      # the squashfs
      export LOCAL_DRIVERS="yes"
      inline_external_file "modprobe-functions"
      probe_early_kernelmodules
    fi

    probe_for_kernelmodule_squashfs
    /bin/busybox sync

    # clean up kernelmodules for unused kernelversions
    purge_unused_kernelmodules  "" "$INITPREF"
    /bin/busybox sync
  fi

  #set +x
  # for some reason it is obscure how kernel >= 2.6.32 does the creation of devfs
  #/bin/busybox ps -A  >> /var/log/livedbg 2>&1
  # since kenel 2.6.32 we have a returned devtmpfs which creates device files automatically
  # however mdev -s is still necessary for some configurations
  # therefore, still do it anyway
  #echoconsole   "$INITPREF" " creating device files in /dev..... "
  #make_devfs "$INITPREF"    2>/dev/null
  # migrated into mount_filesystems 
  if [ "$NOSWAP" = "" ]; then
    check_for_zramswap
  fi
  /bin/busybox sync

}
#
debug_busdevices()
{
  if [ "$DEBUG" != "" -a "$INITDBG" != "" ]; then
    echo "$INITPREF" "$2" >> $1
    #echo "$INITPREF" "Output from 'ls -1R * ' " >> $1
    #/bin/busybox ls -1 /sys   >>  $1
    #/bin/busybox ls  -1R /sys/bus/* >>  $1
    #/bin/busybox ls  -1 /sys/block >>  $1
    #/bin/busybox ls  -1R /sys/devices/* >>  $1
    #/bin/busybox ls -1 /sys/hid/*
    #/bin/busybox ls -1 /proc
    #/bin/busybox ls -1R /proc/bus/*  >>  $1
    #/bin/busybox ls -1R /proc/driver/*  >>  $1
    local FILEDIR
    echo "$INITPREF" "Mounted filesystems " >> $1
    /bin/busybox cat /proc/mounts  2>/dev/null  >> $1
    echo "$INITPREF" "Output from lspci -k" >> $1
    /bin/busybox lspci -k 2>/dev/null  >> $1
    echo "$INITPREF" "Output from lsusb " >> $1
    /bin/busybox lsusb 2>/dev/null   >> $1
    echo "$INITPREF" "Output from /proc/modules" >> $1
    /bin/busybox cat /proc/modules 2>/dev/null   >> $1
    echo "$INITPREF" "Output from /proc/bus/input/devices " >> $1
    /bin/busybox cat  /proc/bus/input/devices 2>/dev/null  >>  $1
    export  >>  $1
    FILEDIR="/sys"
    #busybox find /sys -name modalias -exec cat '{}' \;
    echo "$INITPREF" "Output from uevent files for all in '$FILEDIR'" >> $1
    #for a in "`/bin/busybox find /sys -name "uevent" -print -exec cat '{}' 2>/dev/null \;  `"; do echo "$a" >> $1; done
    #/bin/busybox find $FILEDIR  -name "uevent"  -exec cat '{}' 2>/dev/null \; | /bin/busybox grep MODALIAS 2>/dev/null >> $1
    /bin/busybox find $FILEDIR  -name uevent  -exec cat '{}' 2>/dev/null \; | /bin/busybox grep DRIVER 2>/dev/null >> $1
    echo "$INITPREF" "Output from modalias files" >> $1
    for a in "`/bin/busybox find /sys -name modalias -print -exec cat "{}" 2>/dev/null  \;`"; do echo "$a" >> $1; done
    #local D
    #for D in `/bin/busybox find /sys -name "modalias"  2>/dev/null`; do
    #ls -1 /sys/bus/*/devices/*/modalias 2>/dev/null
    #  echo "-> $D | `/bin/busybox cat $D`" >> $1
    echo "$INITPREF" "END --> $2 <-- END " >> $1
    #done
  fi
}
#
initial_modules_load_defaults()
{
    if [ "`/bin/busybox ls -1 /lib/modules/$KERNVER/kernel  2>/dev/null`" != "" ]; then
     echoconsole  "$INITPREF" " Kernel modules found for '$KERNVER' at '/lib/modules/$KERNVER/kernel'  ...."
     echoconsole  "$INITPREF" " Creating module dependencies for $KERNVER ...."
     #/bin/busybox depmod  >/dev/null 2>&1
     /bin/busybox sync 2>/dev/null
     if [ "$MODPROBE_FUNCTIONS_READ" = "" ]; then
       inline_external_file "modprobe-functions"
     fi
     check_for_depmod
     /bin/busybox sync 2>/dev/null
     echoconsole  "$INITPREF" "Initial Kernel Module probing...."
     debug_busdevices "$MSGFILE" "before probing default pci drivers"
     set_blacklisted_modules
     probe_standardpc_drivers
     /bin/busybox mdev -s  2>/dev/null
     /bin/busybox sync     2>/dev/null
     if [ "$DEBUG" != "" -o "$INITDBG" !=  "" ]; then
       debug_busdevices "$MSGFILE" "debugging for input device drivers "     
       /bin/busybox sleep 2
       if `is_not_string_in_file  "eyboard" "/proc/bus/input/devices" `; then
         debug_busdevices "$MSGFILE" "before probing extraordinarily for inputdrivers"
         probe_inputdevice_drivers
          /bin/busybox mdev -s  2>/dev/null
          /bin/busybox sync     2>/dev/null
         if  `is_not_string_in_file   "eyboard" "/proc/bus/input/devices" `; then
           probe_legacy_inputdevice_drivers
         else
             SYSERRPROMPT=yes
         fi
       else
           SYSERRPROMPT=yes
       fi
        /bin/busybox mdev -s  2>/dev/null
        /bin/busybox sync     2>/dev/null
        echoconsole  "$INITPREF" " after loading initial drivers "
        echoconsole  "$INITPREF" " before probing usb and reading modaliases "
        debug_prompt "$INITPREF"       
     fi
     #probe_usb_devices
     if  `is_not_string_in_file  "eyboard" "/proc/bus/input/devices" `; then
       probe_inputdevice_drivers
       /bin/busybox mdev -s  2>/dev/null
       /bin/busybox sync     2>/dev/null
       if  `is_not_string_in_file  "eyboard" "/proc/bus/input/devices" `; then
         probe_legacy_inputdevice_drivers
         /bin/busybox mdev -s  2>/dev/null
         /bin/busybox sync     2>/dev/null
       else
         SYSERRPROMPT=yes
       fi
     else
       SYSERRPROMPT=yes
     fi
     probe_default_pcidrivers
     remove_unused_modules
     echoconsole  "$INITPREF" " Module probing for architecture whitelisted modules ...."
     inline_external_file WHITELIST_MODULES
     probe_whitelisted_modules  "$INITPREF"
     debug_busdevices "$MSGFILE" "before probing filesystem drivers"
     probe_filesystem_drivers
     /bin/busybox mdev -s  2>/dev/null
     /bin/busybox sync     2>/dev/null
    else
      echoconsole "$INITPREF" " No modules discovered at: /lib/modules/$KERNVER  "
    fi
  
}
#
initial_modules_load_auto()
{

    if [ "`/bin/busybox ls -1 /lib/modules/$KERNVER/kernel  2>/dev/null`" != "" ]; then
     echoconsole  "$INITPREF" " Kernel modules found for '$KERNVER' at '/lib/modules/$KERNVER/kernel'  ...."
     #
     echoconsole  "$INITPREF" "Initial Kernel Module probing...."
     set_blacklisted_modules      
     #debug_busdevices "$MSGFILE" " initial state before probing stdpc drivers "
     #probe_standardpc_drivers
     find_drivers_with_aliases
     # superfluous now
     #find_drivers_refine    
     # probe raw
     set_initial_modules
     set_principal_modules
     remove_duplicate_tokens_from_global_string "MODULES2LOAD"
     #echofile "$INITPREF" "modules : '$MODULES2LOAD'"
     #remove_already_loaded_modules "MODULES2LOAD"
     kernelmodules_order
     export ALLFOUNDMODULES="$MODULES2LOAD"
     debug_busdevices "$MSGFILE" " initial state before probing for initial modalias/pci drivers "
     echofile "$INITPREF" "primary modules to load: '$MODULES2LOAD'"
     kernelmodules_load
     /bin/busybox mdev -s  2>/dev/null
     /bin/busybox sync     2>/dev/null
     debug_busdevices "$MSGFILE" "after 1st run of modaliases / uevents"     
     # there are usbhid adapters for mouse and keyboard that appear as barcode scanners
     # therefore, the use of kbd has to be checked too, 
     # but for the Power Button 
     # the sequence  "sysrq kbd event"  appears to do the job for unique specification  
     if  `is_not_string_in_file  "ouse" "/proc/bus/input/devices" ` || `is_not_string_in_file  "kbd" "/proc/bus/input/devices" `; then
        echofile  "$INITPREF" " initial state before probing input drivers ..."
        probe_inputdevice_drivers
        /bin/busybox mdev -s  2>/dev/null
        /bin/busybox sync     2>/dev/null
        debug_busdevices "$MSGFILE" "... after inputdevice driver loading"     
     fi
     local RC
     RC=11
     for i in 1 2 3; do
       case "$(/bin/busybox cat /proc/bus/input/devices 2>/dev/null)" in
	 *"sysrq kbd event"*|*"kbd leds event"*|*eyboard*|*ouse*|*EV=120013*|*EV=1f*)
	   echoconsole "$INITPREF" "Keyboard | Mouse Driver has been loaded and device(s) appear(s) in bus."
	   SYSERRPROMPT=yes
	   RC=0
	 ;;
	 *Handlers=kbd*)
	    echofile  "$INITPREF" " Not all devices present, probing input drivers ..."
	    probe_inputdevice_drivers
	    /bin/busybox mdev -s  2>/dev/null
	    /bin/busybox sync     2>/dev/null
	    RC=1
	 ;;
	 *)
	    echofile  "$INITPREF" " probing input drivers ...."
	    probe_inputdevice_drivers
	    /bin/busybox mdev -s  2>/dev/null
	    /bin/busybox sync     2>/dev/null
	    debug_busdevices "$MSGFILE" "after inputdevice driver loading"
	    RC=1
	 ;;
       esac
       if [ $RC -eq 0 ] ; then 
	 break
       else
         /bin/busybox sleep 1
       fi
     done
     if [ $RC -eq 1 ]; then
	 probe_legacy_inputdevice_drivers
	 /bin/busybox mdev -s  2>/dev/null
	 /bin/busybox sync     2>/dev/null
	 /bin/busybox sleep 2  2>/dev/null
        if  `is_string_in_file  "ouse" "/proc/bus/input/devices" ` || `is_string_in_file  "kbd" "/proc/bus/input/devices" `; then
	   RC=0
	fi
     else
	 echoconsole "$INITPREF" " Mouse and Keyboard successfully initiated "
     fi
     if [ $RC -ne 0 ]; then
	 if  `is_not_string_in_file  "eyboard" "/proc/bus/input/devices" `; then
	    echofile  "$INITPREF" " initial state before probing input drivers "
	    probe_inputdevice_drivers
	    /bin/busybox mdev -s  2>/dev/null
	    /bin/busybox sync     2>/dev/null
	    debug_busdevices "$MSGFILE" "after inputdevice driver loading"     
	 fi
	 if  `is_not_string_in_file  "sysrq kbd event" "/proc/bus/input/devices" `; then
	     /bin/busybox sleep 1  2>/dev/null
	     probe_inputdevice_drivers
	     /bin/busybox mdev -s  2>/dev/null
	     /bin/busybox sync     2>/dev/null
	     /bin/busybox sleep 2  2>/dev/null
	 else
	     SYSERRPROMPT=yes
	 fi
	 if  `is_not_string_in_file  "sysrq kbd event" "/proc/bus/input/devices" `; then
	 #if  `is_not_string_in_file  "eyboard" "/proc/bus/input/devices" `; then
	   probe_legacy_inputdevice_drivers
	   /bin/busybox mdev -s  2>/dev/null
	   /bin/busybox sync     2>/dev/null
	   /bin/busybox sleep 2  2>/dev/null
	    debug_busdevices "$MSGFILE" "after legacy inputdevice driver loading"     
	 #fi
	 fi
	 if  `is_string_in_file  "sysrq kbd event" "/proc/bus/input/devices" ` || `is_string_in_file  "kbd leds event" "/proc/bus/input/devices" `; then
	   SYSERRPROMPT=yes
	 fi
    #     if  `is_string_in_file  "eyboard" "/proc/bus/input/devices" `; then
    #       SYSERRPROMPT=yes
    #     fi
     fi
     if [ "$DEBUG" != "" -o "$INITDBG" != "" ]; then
         /bin/busybox mdev -s  2>/dev/null
         /bin/busybox sync     2>/dev/null
         /bin/busybox sleep 2
         echoconsole  "$INITPREF" " after loading input keyoard drivers "
         echoconsole  "$INITPREF" " before probing for modalias/pci drivers  "
         debug_mark "$INITPREF"       
     fi
     # repeat
     find_drivers_with_aliases_fast
     # uevent method for kernel driver detecting
     MODULES2LOAD="$MODULES2LOAD `/bin/busybox find /sys  -name uevent  -exec cat '{}' 2>/dev/null \; | /bin/busybox grep DRIVER 2>/dev/null | /bin/busybox cut -f2- -d "=" 2>/dev/null| /bin/busybox tr "-" "_" 2>/dev/null | /bin/busybox tr "\n" " " 2>/dev/null`"
     find_drivers_refine
     find_drivers_with_aliases
     # for Bluetooth INPUT devices , Keyboards and Mouses
     set_initial_modules
     set_principal_modules
     # 
     remove_duplicate_tokens_from_global_string "MODULES2LOAD"
     echofile "$INITPREF" "modules : '$MODULES2LOAD'"
     remove_already_loaded_modules "MODULES2LOAD"
     kernelmodules_order
     export ALLFOUNDMODULES="$ALLFOUNDMODULES $MODULES2LOAD"
     echofile "$INITPREF" "modules to load: '$MODULES2LOAD'"
     kernelmodules_load
     /bin/busybox mdev -s  2>/dev/null
     /bin/busybox sync     2>/dev/null
     #
     if  `is_not_string_in_file  "EV=120013" "/proc/bus/input/devices" `; then
#     if  `is_not_string_in_file  "eyboard" "/proc/bus/input/devices" `; then
       probe_inputdevice_drivers
       /bin/busybox mdev -s  2>/dev/null
       /bin/busybox sync     2>/dev/null
      if  `is_string_in_file  "EV=120013" "/proc/bus/input/devices" `; then
        SYSERRPROMPT=yes
      else
#         if  `is_not_string_in_file  "eyboard" "/proc/bus/input/devices" `; then
	 /bin/busybox sleep 1  2>/dev/null
	 probe_inputdevice_drivers
	 /bin/busybox mdev -s  2>/dev/null
	 /bin/busybox sync     2>/dev/null
	 /bin/busybox sleep 2  2>/dev/null
#         fi
       fi
     fi
     if  `is_string_in_file  "EV=120013" "/proc/bus/input/devices" `; then
       SYSERRPROMPT=yes
     else
#         if  `is_not_string_in_file  "eyboard" "/proc/bus/input/devices" `; then
       probe_legacy_inputdevice_drivers
       /bin/busybox mdev -s  2>/dev/null
       /bin/busybox sync     2>/dev/null
       /bin/busybox sleep 2  2>/dev/null
#         else
#           SYSERRPROMPT=yes
#         fi
#       fi
     fi
     #
     if [ "$DEBUG" != "" -o "$INITDBG" != ""  ]; then
       /bin/busybox mdev -s  2>/dev/null
       /bin/busybox sync     2>/dev/null
       /bin/busybox sleep 2
       echoconsole  "$INITPREF" " after reprobing for input keyoard drivers "
       echoconsole  "$INITPREF" " before reprobing for mouse drivers  "
       #KBDHANDLERS=""
       #KBDHANDLERS=`/bin/busybox grep "sysrq kbd event" /proc/bus/input/devices 2>/dev/null `
       if  `is_not_string_in_file  "EV=120013" "/proc/bus/input/devices" `; then
           echoconsole  "$INITPREF" " Drivers for Keyboard not loaded, abending with prompt! "
       fi
       debug_prompt "$INITPREF"       
       
     fi
     #  the mouse does not matter for yainit in the same way like the keyboard does
     #if  `is_not_string_in_file  "ouse" "/proc/bus/input/devices" `; then
     #  probe_inputdevice_drivers
     #  /bin/busybox mdev -s  2>/dev/null
     #  /bin/busybox sync     2>/dev/null
     #  if  `is_not_string_in_file  "ouse" "/proc/bus/input/devices" `; then
     #    probe_legacy_inputdevice_drivers
     #    /bin/busybox mdev -s  2>/dev/null
     #    /bin/busybox sync     2>/dev/null
         #/bin/busybox sleep 2  2>/dev/null
     #  fi
     #fi
     #
     debug_busdevices "$MSGFILE" "before 3rd run of modaliases / uevents"            
     export MODULES2LOAD=""
     find_drivers_with_aliases
     #find_drivers_refine
     MODULES2LOAD="$MODULES2LOAD `/bin/busybox find /sys  -name uevent  -exec cat '{}' 2>/dev/null \; | /bin/busybox grep DRIVER 2>/dev/null | /bin/busybox cut -f2- -d "=" 2>/dev/null| /bin/busybox tr "-" "_" 2>/dev/null | /bin/busybox tr "\n" " " 2>/dev/null`"
     set_principal_modules
     remove_duplicate_tokens_from_global_string "MODULES2LOAD"
     echofile "$INITPREF" "modules : '$MODULES2LOAD'"
     export ALLFOUNDMODULES="$ALLFOUNDMODULES $MODULES2LOAD"
     remove_already_loaded_modules "MODULES2LOAD"
     echofile "$INITPREF" "modules to load: '$MODULES2LOAD'"
     kernelmodules_order
     kernelmodules_load
     #
     debug_busdevices "$MSGFILE" "after 3rd run of modalias/uevent, before removing unused drivers"
     echoconsole  "$INITPREF" " Remove unused modules...."
     remove_duplicate_tokens_from_global_string "ALLFOUNDMODULES"
     remove_unused_modules
     #
     debug_busdevices "$MSGFILE" "before probing filesystem drivers"
     probe_filesystem_drivers
     /bin/busybox sync     2>/dev/null

    else
      echoconsole "$INITPREF" " No modules discovered at: /lib/modules/$KERNVER  "
    fi
  
}
#
boot_on()
{
  #
  #  PHASE 3
  #  set busybox symlinks for all applets
  #  load modules if any installed and access root device
  #
  # install symlinks for busybox AFTER all the customized and optimized files are there!
  echoconsole    "$INITPREF" " Installing all symlinks for busybox....."
  set_bbsymlinks "$INITPREF"
  /bin/busybox sync
  # switch any overwritten /bin/ash or /sbin/ash files back to /bin/busybox

  /bin/busybox rm -f  /bin/ash /sbin/ash /bin/sh /sbin/sh /usr/bin/ash /usr/sbin/ash /usr/bin/sh /usr/sbin/sh 2>/dev/null
  /bin/busybox ln -sf /bin/busybox /bin/ash    2>/dev/null
  /bin/busybox ln -sf /bin/ash     /bin/sh   2>/dev/null
  /bin/busybox sync
  
  if [ "$LOCAL_DRIVERS" = "" -o "$NOMOD" != "" ]; then
    echoconsole  "$INITPREF" "No local drivers at /lib/modules/$KERNVER found! Continuing...."    
  fi

  if [ "$NOMOD" = "" -a "$LOCAL_DRIVERS" != "" ]; then
     # kernelmodules need in some configurations the debugfs mounted to load
     # if no debugfs compiled in , it does not hurt
     if  `is_not_string_in_file  "debugfs"  "/proc/mounts" `; then 
       mount_debugfs
       /bin/busybox sync 2>/dev/null
     fi
     # the following only if explicitly specified by default or parameter
     if  [ "$DEVTMPFS" != "" ] ; then 
       mount_devtmpfs
       /bin/busybox sync 2>/dev/null
     fi
     if  [ "$DEVPTS" != "" ] ; then 
       mount_devpts
       /bin/busybox sync 2>/dev/null
     fi
     if  [ "$HUGETLBFS" != "" ] ; then 
       mount_hugetlbfs
       /bin/busybox sync 2>/dev/null
     fi
     if [ "$MODPROBE_FUNCTIONS_READ" = "" ]; then
       inline_external_file "modprobe-functions"
       /bin/busybox mdev -s  2>/dev/null
       /bin/busybox sync     2>/dev/null
     fi     
     
     check_for_depmod
     # load modules if any resident in INITRAMFS
     if [ "$NOAUTO" != "" ]; then
       initial_modules_load_defaults
     else
       initial_modules_load_auto
     fi
     if [ "$NOSWAP" = "" ]; then 
       check_for_zramswap
     fi
    
  fi
  # check busybox before entering debug prompt
  if [ "$DEBUG" != "" -o "$INITDBG" != "" ]; then
    bbversion_check
    bbapplets_check
  fi
  
  if [ "$DEBUG" != "" -o "$INITDBG" != "" ]; then
    echoconsole  "$INITPREF" " init parameters: '$INITPARAMETERS' "
    echoconsole  "$INITPREF" " before branching out of init... "
    debug_prompt "$INITPREF"
  fi
}
#
echoconsole "[ initrd-functions ]:" "read in!"
#

