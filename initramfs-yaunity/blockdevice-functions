#
#
MAINDEVPATH=""
MAINDEV=""
BLKDEV=""
BLKDEVPART=""
PNUM=""
DISKPUUID=""
LABELDD=""
SECTSIZE=""
STARTSECT=""
ENDSECT=""
FS=""
DOSTABLE=""
PUUID=""
PARTUUID=""
BLOCKDISKS=""
BLOCKDEVS=""
BLOCKDEVPARTS=""
#
EBRENTRIES=""#
LABELCONTAINER=""
label=""
LABEL=""
UUID=""
LABEL_sda1=""
LABEL_sda2=""
LABEL_sda3=""
LABEL_sda4=""
LABEL_sdb1=""
LABEL_sdb2=""
LABEL_sdb3=""
LABEL_sdb4=""
LABEL_sdc1=""
LABEL_sdc2=""
LABEL_sdc3=""
LABEL_sdc4=""
LABEL_sdd1=""
LABEL_sdd2=""
LABEL_sdd3=""
LABEL_sdd4=""
LABEL_sde1=""
LABEL_sde2=""
LABEL_sde3=""
LABEL_sde4=""
LABEL_sdf1=""
LABEL_sdf2=""
LABEL_sdf3=""
LABEL_sdf4=""
LABEL_sdg1=""
LABEL_sdg2=""
LABEL_sdg3=""
LABEL_sdg4=""
LABEL_sdh1=""
LABEL_sdh2=""
LABEL_sdh3=""
LABEL_sdh4=""
LABEL_sdi1=""
LABEL_sdi2=""
LABEL_sdi3=""
LABEL_sdi4=""
LABEL_sdj1=""
LABEL_sdj2=""
LABEL_sdj3=""
LABEL_sdj4=""
LABEL_sdk1=""
LABEL_sdk2=""
LABEL_sdk3=""
LABEL_sdk4=""
PARTUUID_sda1=""
PARTUUID_sda2=""
PARTUUID_sda3=""
PARTUUID_sda4=""
PARTUUID_sdb1=""
PARTUUID_sdb2=""
PARTUUID_sdb3=""
PARTUUID_sdb4=""
PARTUUID_sdc1=""
PARTUUID_sdc2=""
PARTUUID_sdc3=""
PARTUUID_sdc4=""
PARTUUID_sdd1=""
PARTUUID_sdd2=""
PARTUUID_sdd3=""
PARTUUID_sdd4=""
PARTUUID_sde1=""
PARTUUID_sde2=""
PARTUUID_sde3=""
PARTUUID_sde4=""

#
export GB=$(( 1024 * 1024 * 1024 ))
export MB=$(( 1024 * 1024 ))
export KB=1024
export BYTE=8
#
read_fdiskline()
{
  FS=""
  STARTSECT=""
  #if [ "$2" = "*" ]; then shift; fi
  export STARTSECT="$2"
  export FS="$5"
}
#
assign_devpath_string()
{
  local RC
  #BLKDEV=""
  local string sysblkdev bdevs
  string="$1"
  bdevs=""
  #BLKDEVPART=""
  #MAINDEVPATH=""
  string=`/bin/busybox readlink -f "$string" 2>/dev/null`
  BLKDEVPART=`/bin/busybox basename "$string" 2>/dev/null`
  MAINDEVPATH=`/bin/busybox dirname "$string" 2>/dev/null`
  if [ "${MAINDEVPATH#/dev}" = "${MAINDEVPATH}" ]; then
    echo ""
    RC=127
  fi
  #MAINDEV=""
  export MAINDEVPATH
  sysblkdev=""
  for sysblkdev in $(/bin/busybox ls -1 /sys/block 2>/dev/null | /bin/busybox tr "\n" " " 2>/dev/null); do
    case $BLKDEVPART in
      *$sysblkdev*)
        bdevs=$sysblkdev
      ;;
    esac
  done
  if [ "$bdevs" != "" ]; then 
    if [ "$bdevs" != "$BLKDEVPART" ]; then 
      BLKDEV="$bdevs"
      PNUM=`last_digits_of_string "$BLKDEVPART"`
    else
      BLKDEV="$BLKDEVPART"
      BLKDEVPART=""  
      PNUM=""
    fi
    MAINDEV="${MAINDEVPATH}/${BLKDEV}"
    export BLKDEV BLKDEVPART PNUM MAINDEV 
    echo "$MAINDEV"
    RC=0
    #return 0
  else
    echo ""
    RC=1
    #return 1
  fi
  return $RC
}
#
devicenumber()
{
  # extract devicenumber from a Linux device path string 
  # this has become necessary since the GPT specification
  local i LEN PLACE VAR DIGIT LASTDIGIT NUMBER
  VAR="$1"
  LEN=${#VAR}
  #echo LEN $LEN
  #i=1
  PLACE=0
  LASTNUMBER=""
  NUMBER=""
  DIGIT=""
  for i in `seq 1 $LEN`; do
    PLACE=$(( $LEN - $i ))
    NUMBER=${VAR:$PLACE:$i}
    DIGIT=${VAR:$PLACE:1}
    #echo "DIGIT=$DIGIT"
    if `is_char_not_digit $DIGIT`; then 
      echo "$LASTNUMBER"
      #break
      return 0
    fi 
    LASTNUMBER=$NUMBER
  done
  echo ""
  return 1
}
#
assign_specified_partition_parameters()
{

  local PARTDEV BLOCKDEV FIRSTSECT LASTSECT FILESYS DEVICE LABELCONTAINER line1 line2 line3 SKIPPER
  local LABEL UUID FSTYPE LABELDD FSMAGIC FSSUBTYPE EXPORTVARIABLES
  DEVICE="$1" 
  [ "$DEVICE" != "" ] || return  127
  FIRSTSECT="$2"
  SKIPPER=0
  [ "$BLKDEV" != "" ] || MAINDEV=`assign_devpath_string $DEVICE`
  [ "$BLKDEVPART" != "" ] ||  BLKDEVPART=`/bin/busybox basename $DEVICE 2>/dev/null` 
  if [ "$DEVICE" = "$MAINDEV" ]; then 
     SKIPPER=$FIRSTSECT
  else
     BLKDEVPART=`/bin/busybox basename $DEVICE 2>/dev/null` 
  fi
  LASTSECT="$3"
  FILESYS="$4"
  [ "$FILESYS" != "" ] || FILESYS="$FS"
  [ "$FILESYS" != "" ] || 
  {
    echoconsole "$INITPREF" "Type of Partition Filesystem not found or specified for "
    echoconsole "$INITPREF" "Partition '$DEVICE' at sectors '$FIRSTSECT' through '$LASTSECT' "
    echoconsole "$INITPREF" "Abending .... "
    return 127
  } 
  UUID=""
  FSTYPE=""
  FSSUBTYPE=""
  LABELDD=""
  LABELCONTAINER=""
  line1=""
  line2=""
  line3=""
  case $FILESYS in
    83|ee|ef)
        LABELCONTAINER=`/bin/busybox dd if=$DEVICE bs=$SECTSIZE skip=$SKIPPER count=4 2>/dev/null | /bin/busybox hexdump -C 2>/dev/null`
        
        line1=$(echo "$LABELCONTAINER" |  /bin/busybox grep "00000430" 2>/dev/null)
        FSMAGIC="$(echo "${line1:35:5}" | /bin/busybox tr -d "/\.\`\+\\" 2>/dev/null)"
        if [ "$FSMAGIC" = "53 ef" ]; then 
          FSSUBTYPE="extfs"
          #export FSSUBTYPE; 
          line2=$(echo "$LABELCONTAINER" |  /bin/busybox grep "00000500" 2>/dev/null)
          FSMAGIC="${line2:47:5}" #| /bin/busybox tr -d "/\.\`\+\\" 2>/dev/null)"
          if [ "$FSMAGIC" = "0a f3" ]; then 
            FSTYPE="ext4"
            #export FSTYPE; 
	  else
	    FSTYPE=$FSSUBTYPE
          fi
        fi
        line1=$(echo "$LABELCONTAINER" |  /bin/busybox grep "00000400" 2>/dev/null)
        FSMAGIC="$(echo "${line1:10:11}" | /bin/busybox tr -d "/\.\`\+\\" 2>/dev/null)"
        if [ "$FSMAGIC" = "10 20 f5 f2" ]; then 
          FSTYPE="f2fs"
          #export FSSUBTYPE; 
        fi
        line1=$(echo "$LABELCONTAINER" |  /bin/busybox grep "00000000" 2>/dev/null)
        FSMAGIC="$(echo "${line1:10:11}" | /bin/busybox tr -d "/\.\`\+\\" 2>/dev/null)"
        if [ "$FSMAGIC" = "58 46 53 42" ]; then # XFSB 
          FSTYPE="xfs"
          #export FSSUBTYPE; 
        fi
        case "$FSTYPE" in
	  *ext*)
	    line1=$(echo "$LABELCONTAINER" |  /bin/busybox grep "00000460" 2>/dev/null)
	    line2=$(echo "$LABELCONTAINER" |  /bin/busybox grep "00000470" 2>/dev/null)
	    line3=$(echo "$LABELCONTAINER" |  /bin/busybox grep "00000480" 2>/dev/null)
	    LABELDD="$(echo "${line2:69:8}${line3:61:8}" | /bin/busybox tr -d "/\.\`\+\\" 2>/dev/null)"
	    UUID="${line1:35:23}${line2:10:23}"
	  ;;
	  *f2fs*)
	    line1=$(echo "$LABELCONTAINER" |  /bin/busybox grep "00000470" 2>/dev/null) 
	    line2=$(echo "$LABELCONTAINER" |  /bin/busybox grep "00000480" 2>/dev/null) 
	    line3=$(echo "$LABELCONTAINER" |  /bin/busybox grep "00000490" 2>/dev/null) 
	    LABELDD="$(echo "${line1:73:4}${line2:61:16}${line3:61:16}" | /bin/busybox tr -d "/\.\`\+\\" 2>/dev/null)"
	    line3=$(echo "$LABELCONTAINER" |  /bin/busybox grep "00000460" 2>/dev/null) 
	    UUID="${line3:47:12}${line1:10:36}" 	  ;;
	  *xfs*)
	    line1=$(echo "$LABELCONTAINER" |  /bin/busybox grep "00000060" 2>/dev/null) 
	    line2=$(echo "$LABELCONTAINER" |  /bin/busybox grep "00000070" 2>/dev/null) 
	    LABELDD="$(echo "${line1:73:4}${line2:61:16}${line3:61:16}" | /bin/busybox tr -d "/\.\`\+\\" 2>/dev/null)"
	    line3=$(echo "$LABELCONTAINER" |  /bin/busybox grep "00000240" 2>/dev/null) 
	    UUID="${line3:10:48} #| /bin/busybox tr -d "/\.\`\+\\" 2>/dev/null)"
	  ;;
	esac 
        #echo "UUID=$UUID"
	UUID="$(echo ${UUID} | /bin/busybox tr -d " " 2>/dev/null)"
	UUID="${UUID:0:8}-${UUID:8:4}-${UUID:12:4}-${UUID:16:4}-${UUID:20:12}"
    ;;
    5|f|0f|85|f2)  # extended partitions
      LABELDD=ExtdXNonBootable
    ;;
    7|07)
        #LABELCONTAINER=`/bin/busybox dd if=$DEVICE bs=$SECTSIZE skip=$SKIPPER count=4 2>/dev/null | /bin/busybox hexdump -C 2>/dev/null`
        LABELCONTAINER=`/bin/busybox dd if=$DEVICE bs=4096 skip=0 count=8 2>/dev/null | /bin/busybox hexdump -C 2>/dev/null`
        #echo "$LABELCONTAINER"
        #echo "fs type '$FS'"
        line1=$(echo "$LABELCONTAINER" |  /bin/busybox cut -c 62-77  2>/dev/null | /bin/busybox tr -d ".\n " 2>/dev/null)
        if `is_substring_of "NTFS" "$line1" ` || `is_substring_of "NTLDR" "$line1"`; then 
           FSTYPE=ntfs
        else
           echo "strange first sector of ntfs-type partition, no NTLDR, no NTFS detected!"
        fi
        line1=$(echo "$LABELCONTAINER" |  /bin/busybox grep "00000000" 2>/dev/null)
        FSMAGIC=${line1:11:8}         
        if [ "$FSMAGIC" = "eb 52" ]; then 
          FSSUBTYPE="ntfs"
          #export FSSUBTYPE; 
        fi
        #FSTYPE=ntfs
        #line1=$(echo "$LABELCONTAINER" |  /bin/busybox grep "00004d80" 2>/dev/null) 
        #line2=$(echo "$LABELCONTAINER" |  /bin/busybox grep "00004d90" 2>/dev/null) 
        #LABELDD="$(echo "${line1:61:16}${line2:61:5}" | /bin/busybox tr -d " \.\`\+\\" 2>/dev/null)"
        line1=$(echo "$LABELCONTAINER" |  /bin/busybox grep "00004d10" 2>/dev/null) 
        line2=$(echo "$LABELCONTAINER" |  /bin/busybox grep "00004d20" 2>/dev/null) 
        LABELDD="$(echo "${line1:67:9}${line2:61:14}" | /bin/busybox tr -d " \.\`\+\\" 2>/dev/null)"
        line3=$(echo "$LABELCONTAINER" |  /bin/busybox grep "00000040" 2>/dev/null) 
        UUID="${line3:35:25}"
        TOK=""
        for id in $UUID; do
          TOK="$id$TOK"
        done
        UUID="$TOK"
        UUID="$(echo ${UUID} | /bin/busybox tr -d " " 2>/dev/null)"
    ;;
    c|0c|0b|b)
        LABELCONTAINER=`/bin/busybox dd if=$DEVICE bs=$SECTSIZE skip=$SKIPPER count=4 2>/dev/null | /bin/busybox hexdump -C 2>/dev/null`
        #echo "$LABELCONTAINER"
        line1=$(echo "$LABELCONTAINER" |  /bin/busybox grep "00000000" 2>/dev/null)
        FSMAGIC=${line1:11:8}         
        if [ "$FSMAGIC" = "eb 58" ]; then 
          FSSUBTYPE="vfat"
          #export FSSUBTYPE; 
        fi
        #echo "$0 dev $DEVICE with fstype '$FS'"
        line1=$(echo "$LABELCONTAINER" |  /bin/busybox grep "00000040" 2>/dev/null) 
        line2=$(echo "$LABELCONTAINER" |  /bin/busybox grep "00000050" 2>/dev/null) 
        LABELDD="$(echo "${line1:68:8}${line2:61:2}" | /bin/busybox tr -d " \.\`\+\\" 2>/dev/null)"
        UUID="${line1:19:11}" #| /bin/busybox tr -d "/\.\`\+\\" 2>/dev/null)"
        TOK=""
        for id in $UUID; do
          TOK="$id$TOK"
        done
        UUID="$TOK"
        UUID="$(echo ${UUID} | /bin/busybox tr -d " " 2>/dev/null)"
        UUID="${UUID:0:4}-${UUID:4:4}"
        #echo "UUID=$UUID"
        #export UUID
        FSMAGIC="${line2:63:5}"  #| /bin/busybox tr -d "/\.\`\+\\" 2>/dev/null)"
        if [ "$FSMAGIC" = "FAT32" ]; then 
          FSTYPE="vfat" 
          #export FSTYPE
        fi
    ;;
    6|4)# FAT16
        LABELCONTAINER=`/bin/busybox dd if=$DEVICE bs=$SECTSIZE skip=$SKIPPER count=4 2>/dev/null | /bin/busybox hexdump -C 2>/dev/null`
        #echo "$LABELCONTAINER"
        #echo "fs type '$FS'"
        line1=$(echo "$LABELCONTAINER" |  /bin/busybox grep "00000020" 2>/dev/null) 
        line2=$(echo "$LABELCONTAINER" |  /bin/busybox grep "00000030" 2>/dev/null) 
        LABELDD="$(echo "${line1:71:6}${line2:61:6}" | /bin/busybox tr -d " \.\`\+\\" 2>/dev/null)"
        FSTYPE="fat16"
    ;;
    11|14|16|17|1b|1c|1e|27|84)  # hidden partitions
      LABELDD=HiddenXnoaccess
    ;;
    82|18|b8|16|17|1b|1c|1e|27|84)  # swap partitions
      LABELDD=SwapXnoaccess
    ;;
    8|9)  # extended partitions
      LABELDD=AIXorAIXBootable
    ;;
    5|f|0f|85|f2)  # extended partitions
      LABELDD=ExtdXNonBootable
    ;;
    4d|4e|4f)  # extended partitions
      LABELDD=QNX4xUpTo3rdLVL
    ;;
    f2)  # extended partitions
      LABELDD=DOS2ndary
    ;;
    e4|f1|f4)  # extended partitions
      LABELDD=DOS2ndary
    ;;
    80|81)  # extended partitions
      LABELDD=Minix
    ;;
    a|0a)  # extended partitions
      LABELDD=OS2BootMan
    ;;
  esac
  #echo "$LABELCONTAINER"
  #export LABELDD
  LABEL="$LABELDD"
  STARTSECTOR=$FIRSTSECT
  ENDSECTOR=$LASTSECT
  #echo "[ $0 ]: $DEVICE: SSIZE=\"$SECTSIZE\" STARTS=\"$STARTSECTOR\" ENDS=\"$ENDSECTOR\" TYPE=\"$FSTYPE\" LABEL=\"$LABEL\" PUUID=\"$PARTUUID\" UUID=\"$UUID\" PTTYPE=\"$PTTYPE\" "
  #echo "FilesystemLabel: $LABEL , partuuid $PARTUUID"
  EXPORTVARIABLES="LABEL UUID FSTYPE SECTSIZE STARTSECTOR ENDSECTOR PTTYPE"
  local varcontent=""
  local var=""
  local us="_"
  for var in $EXPORTVARIABLES; do
    #TOK="varcontent=\$$var"
    eval "varcontent=\$$var"
    #echo "variable : $var and content $varcontent /partition: $PARTNUM"
    if [ "$varcontent" != "" ]; then
      assign_array_variable "${var}${us}" "$BLKDEVPART" "$varcontent"   
    fi
  done
  LABELCONTAINER=""

}
#
assign_msdos_partition()
{
  local DEV PARTDEV fdiskline DISKID line1 line2 TOK 
  local counter
  if [ 0$PNUM -eq 0 ];then 
    return 127
  fi
  PARTDEV=""
  PARTDEVS=""
  DEV="$1"
  STARTSECT=""
  ENDSECT=""
  line1=""
  line2=""
  TOK=""
  PARTDEV="$BLKDEVPART"
  #PNUM=$(echo ${DEV} | /bin/busybox tr -d "\/[:alpha:]" 2>/dev/null)
  export PTTYPE=dos
  TOK="PTTYPE_"
  TOK="${TOK}${PARTDEV}"
  TOK="$TOK=\"${PTTYPE}\""
  eval "$TOK"
  #export "PTTYPE_$PARTDEV"
  export $TOK
  counter=0
  for line in $DOSTABLE; do
    #if [ "$line" != "00000000000000000000000000000000" ]; then
      counter=$(( $counter + 1 ))
    #else
    # continue
    #fi
    if [ $counter -eq $PNUM ]; then
      TOK=""
      for i in 16 18 20 22; do
         TOK="${line:$i:2}$TOK"
      done
      TOK=$(echo $TOK | /bin/busybox tr -d " " 2>/dev/null)
      STARTSECT=$(( 0x$TOK ))
      TOK=""
      for i in 24 26 28 30; do
         TOK="${line:$i:2}$TOK"
      done
      TOK=$(echo $TOK | /bin/busybox tr -d " " 2>/dev/null)
      ENDSECT=$(( 0x$TOK ))
      #echo "Startsector of partition $PNUM : $STARTSECT"
      #echo "Endsector   of partition $PNUM : $ENDSECT"
      FS=${line:8:2}
      export FS
      echo "FS=$FS"
      #set -x
      assign_specified_partition_parameters "$DEV" "$STARTSECT" "$ENDSECT" "$FS"
      #set  +x
      TOK="PARTUUID_"
      TOK="$TOK$PARTDEV=${PUUID}-0${PNUM}"
      #echo "TOK=$TOK"
      eval "$TOK"
      export $TOK
      #export "PARTUUID_$PARTDEV"
      break
    fi
  done
  
  #TOK="PARTUUID_$PARTDEV=\"${PUUID}\""
  #eval "$TOK"
  #export "PARTUUID_$PARTDEV"

}
#
assign_msdos_partitiontable()
{
  local DEV P PARTDEV PART fdiskline DISKID OLDMAINDEV line1 line2 TOK RC
  local LABELCONTAINER PART_1 PART_2 PART_3 PART_4 var count
  PARTDEV=""
  PARTDEVS=""
  DEV="$1"
  STARTSECT=""
  LENSECT=""
  ENDSECT=""
  line1=""
  line2=""
  TOK=""
  #PARTDEV="`/bin/busybox basename $MAINDEV 2>/dev/null`"
  MAINDEV=`assign_devpath_string $DEV`
  RC=$?
  if [ 0$RC -ne 0 ]; then
    return 127
  fi
  BLKDEVPART="`/bin/busybox basename $DEV 2>/dev/null`" 
  PNUM=`last_digits_of_string $BLKDEVPART`
  BLKDEV=${BLKDEVPART//$PNUM}
  MAINDEVPATH="`/bin/busybox dirname $DEV 2>/dev/null`" 
  PARTDEV="$BLKDEV"
  export PTTYPE=dos
  TOK=""
  TOK="PTTYPE_$PARTDEV=$PTTYPE"
  eval "$TOK"
  export "PTTYPE_$PARTDEV"
  count=0
  for partdev in `/bin/busybox ls -1 $MAINDEV* 2>/dev/null`; do
    TOK="PART_${count}=$(/bin/busybox basename $partdev)"
    eval $TOK
    count=$(( $count + 1 ))
  done
  # DOSTABLE 
  #echo DOSTABLE  $DOSTABLE
  P=1
  for line in $DOSTABLE; do
    if [ "$line" != "00000000000000000000000000000000" ]; then
      TOK=""
      for i in 16 18 20 22; do
         TOK="${line:$i:2}$TOK"
      done
      TOK=$(echo $TOK | /bin/busybox tr -d " " 2>/dev/null)
      STARTSECT=$(( 0x$TOK ))
      TOK=""
      for i in 24 26 28 30; do
         TOK="${line:$i:2}$TOK"
      done
      TOK=$(echo $TOK | /bin/busybox tr -d " " 2>/dev/null)
      LENSECT=$(( 0x$TOK ))
      ENDSECT=$(( $STARTSECT + $LENSECT -1 ))
      #echo "Startsector of partition $PNUM : $STARTSECT"
      #echo "Endsector   of partition $PNUM : $ENDSECT"
      FS=${line:8:2}
      var="PART_${P}"
      TOK="PARTDEV=\$$var"
      eval "$TOK"
      assign_specified_partition_parameters "$MAINDEVPATH/$PARTDEV" "$STARTSECT" "$ENDSECT" "$FS"
      TOK="PARTUUID_${PARTDEV}=${PUUID}-0${P}"
      eval "$TOK"
      export "PARTUUID_${PARTDEV}"
    fi
    #TOK=""
    P=$(( $P + 1 ))
  done
  
  PARTUUID=$PUUID
  PARTDEV="$BLKDEV"
  TOK="PARTUUID_$PARTDEV=\"${PUUID}\""
  eval "$TOK"
  export "PARTUUID_$PARTDEV" PARTUUID

}
#
assign_gpt_partuuid()
{
 local VAR STRING RETVAR tok byte0 byte1 byte2 byte3
  if [ "$1" != "" ]; then
    VAR="$1"
    #echo "$VAR"
    STRING="${VAR:0:8}"
    RETVAR=""
    for i in 0 2 4 6; do
      RETVAR="${STRING:$i:2}$RETVAR"
    done
    #echo " $RETVAR"
    RETVAR="$RETVAR-${VAR:10:2}"
    RETVAR="$RETVAR${VAR:8:2}"
    #echo " $RETVAR"
    RETVAR="$RETVAR-${VAR:14:2}"
    RETVAR="$RETVAR${VAR:12:2}"
    #echo " $RETVAR"
    RETVAR="$RETVAR-${VAR:16:2}"
    RETVAR="$RETVAR${VAR:18:2}"
    #echo " $RETVAR"
    RETVAR="$RETVAR-${VAR:20:12}"
    echo "$RETVAR"
    
    export PARTUUID="$RETVAR"
    return 0
  else
    return 127
  fi
}
#
#
assign_gpt_partitiontable()
{
  local DEVSZ PNUM PARTDEV DEV line1 line2 line3 counter TOK PTABLE GPTHDRCONTAINER
  #local SSBYTE0 SSBYTE1 SSBYTE2 SSBYTE3
  #local ESBYTE0 ESBYTE1 ESBYTE2 ESBYTE3 
  local line
  DEV="$1"
  #PARTDEV=$(/bin/busybox basename $DEV 2>/dev/null)
  MAINDEV=`assign_devpath_string $DEV`
  RC=$?
  if [ 0$RC -ne 0 ]; then
    return 127
  fi
  BLKDEVPART="`/bin/busybox basename $DEV 2>/dev/null`" 
  PNUM=`last_digits_of_string $BLKDEVPART`
  BLKDEV=${BLKDEVPART//$PNUM}
  MAINDEVPATH="`/bin/busybox dirname $DEV 2>/dev/null`" 
  PARTDEV="$BLKDEV"
  #PARTDEV=$BLKDEV
  #PNUM=""
  #PNUM=`last_digits_of_string $PARTDEV`
  #TOK=$(echo $PARTDEV | /bin/busybox tr -d "[:digit:]" 2>/dev/null)
  #if [ "$PNUM" != "" ]; then
  #  echo "[ $0 ] : You can specify only the device path of an entire blockdevice"
  #  echo "[ $0 ] : no particular partition ! '$MAINDEV' void."
  #  return 255
  #fi
  DEVSZ=`/bin/busybox blockdev --getsz $DEV 2>/dev/null`
  STARTSECT=0
  ENDSECT=0
  line1=""
  line2=""
  line=""
  TOK=""
  LABELDD=""
  line1=$(echo $DOSTABLE | /bin/busybox cut -f1   -d " " 2>/dev/null)
  line2=$(echo $DOSTABLE | /bin/busybox cut -f2   -d " " 2>/dev/null)
  #echo $line1
  #echo $line2
  if [ "$line1" != "" -a  "$line2" = "00000000000000000000000000000000" ]; then
      TOK=""
      for i in 16 18 20 22; do
         TOK="${line1:$i:2}$TOK"
         #echo $TOK $i ${line1:$i:2}
      done
      TOK=$(echo $TOK | /bin/busybox tr -d " " 2>/dev/null)
      #echo "startsect $TOK"
      STARTSECT=$(( 0x$TOK ))
      TOK=""
      for i in 24 26 28 30; do
         TOK="${line1:$i:2}$TOK"
         #echo $TOK
      done
      TOK=$(echo $TOK | /bin/busybox tr -d " " 2>/dev/null)
      #echo "endsect $TOK"
      ENDSECT=$(( 0x$TOK ))
      #echo "Startsector of partition $PNUM : $STARTSECT"
      #echo "Endsector   of partition $PNUM : $ENDSECT"
    if [ $DEVSZ -ne $(( $ENDSECT + 1 )) ]; then 
      echo "Device size $DEVSZ for $DEV is not matching with endsector number of GPT !"
      echo "abending...."
      return 255
    fi
  else
     echo "Partition has Filesystem '$FS' but no valid MBR contents for a GPT !"
     echo "abending...."
    return 255
  fi
  #PTABLE=`/bin/busybox dd if=$MAINDEV bs=$SECTSIZE skip=0 count=128 2>/dev/null | /bin/busybox hexdump -C   2>/dev/null`
  #line1=`echo "$PTABLE" | /bin/busybox hexdump -C   2>/dev/null`
  #echo "$PTABLE"
  # read the next sector after the startsector, that should contain the GPT-MBR
  PTABLE=`/bin/busybox dd if=$MAINDEV bs=$SECTSIZE skip=$STARTSECT count=1 2>/dev/null | /bin/busybox hexdump -C   2>/dev/null`
  #echo "$PTABLE"
  line1=$(echo "$PTABLE" |  /bin/busybox grep "00000000" 2>/dev/null) 
  LABELDD="$(echo "${line1:61:8}" | /bin/busybox tr -d "/\.\`\+\\" 2>/dev/null)"
  #echo $LABELDD
  if [ "$LABELDD" != "EFI PART" ]; then 
    echo "Partition has no valid GUUID Partition Table Descriptor !"
    echo "Expected 'EFI PART' in the startsector referenced by MS-DOS Partition table"
    export PTTYPE=""
    echo "abending...."
    return 255
  else
    export PTTYPE="gpt"
    TOK=""
    TOK="PTTYPE_$PARTDEV=\"$PTTYPE\""
    eval "$TOK"
    export "PTTYPE_$PARTDEV"
  fi
  LABELDD="$(echo "${line1:47:11}" | /bin/busybox tr -d "/\.\`\+\\" 2>/dev/null)"
  GPTHDRSIZE=""
  for byte in $LABELDD; do
    GPTHDRSIZE="$byte$GPTHDRSIZE"
  done 
  
  GPTHDRSIZE=$(( 0x${GPTHDRSIZE} ))
  export GPTHDRSIZE
  #echo GPTHDRSIZE  $GPTHDRSIZE
  line1=$(echo "$PTABLE" |  /bin/busybox grep "00000030" 2>/dev/null) 
  line2=$(echo "$PTABLE" |  /bin/busybox grep "00000040" 2>/dev/null) 
  LABELDD="$(echo "${line1:35:23} ${line2:10:23}" | /bin/busybox tr -d "/\.\`\+\\" 2>/dev/null)"
  #echo $LABELDD
  PUUID="$(echo $LABELDD  | /bin/busybox tr -d " " 2>/dev/null)"
  #echo $PUUID
  PUUID=`assign_gpt_partuuid "$PUUID"`
  #echo "first assigned puuid : $PUUID"
  DISKUUID="$PUUID"
  export DISKUUID
  TOK=""
  TOK="PARTUUID_$PARTDEV=\"$DISKUUID\""
  eval "$TOK"
  export "PARTUUID_$PARTDEV"
  line2=$(echo "$PTABLE" |  /bin/busybox grep "00000050" 2>/dev/null) 
  LABELDD="$(echo "${line2:10:12}" | /bin/busybox tr -d "/\.\`\+\\" 2>/dev/null)"
  #echo $LABELDD
  TOK=""
  for byte in $LABELDD; do
    TOK="$byte$TOK"
  done
  GPTSIZE=$(( 0x$TOK ))
  #echo GPTSIZE $GPTSIZE
  GPTHDRID="af 3d c6 0f 83 84 72 47  8e 79 3d 69 d8 47 7d e4"
  EFIID="  ba 4b 00 a0 c9 3e c9 3b"
  NILLINE="00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|"
  GPTHDRCONTAINER=""
  start=2
  counter=0
  for cnt in `seq 0 127`; do 
    GPTHDRCONTAINER=`/bin/busybox dd if=$DEV bs=$GPTSIZE skip=$(( $start + $cnt )) count=1 2>/dev/null | /bin/busybox hexdump -C 2>/dev/null`
    line1=$(echo "$GPTHDRCONTAINER" |  /bin/busybox grep "00000000" 2>/dev/null)
    #echo "no. ($cnt,$(( $start + $cnt )) partitionheader no. $counter at $(( $GPTSIZE * $(( $start + $cnt )) ))"
    #echo "$GPTHDRCONTAINER"
    if `is_substring_of "$GPTHDRID" "$line1"` || `is_substring_of "$EFIID" "$line1"`; then 
     counter=$(( $counter + 1 ))
     #echo "no. ($cnt,$(( $start + $cnt )) partitionheader no. $counter at $(( $GPTSIZE * $(( $start + $cnt )) ))"
     #echo "$GPTHDRCONTAINER"
     line2=$(echo "$GPTHDRCONTAINER" |  /bin/busybox grep "00000010" 2>/dev/null)
     PUUID=${line2:10:48}
     PUUID=$(echo $PUUID|/bin/busybox tr -d " " 2>/dev/null)
     #echo "PARTUUID of $counter,$PNUM $PARTUUID"
     PUUID=`assign_gpt_partuuid "$PUUID"`
     TOK=""
     TOK="PARTUUID_$PARTDEV$counter=\"$PUUID\""
     eval "$TOK"
     PARTUUID=$PUUID
     export "PARTUUID_$PARTDEV$counter" PARTUUID
     #echo "Partuuid='$PARTUUID'"
     line2=$(echo "$GPTHDRCONTAINER" |  /bin/busybox grep "00000020" 2>/dev/null)
     STARTLBA=${line2:10:23}
     ENDLBA=${line2:35:23}
     #echo "startlba='$STARTLBA'  endlba='$ENDLBA'"
     TOK=""
     for s in $STARTLBA; do
       TOK="$s$TOK"
     done
     STARTLBA=$(( 0x$TOK ))
     TOK=""
     for e in $ENDLBA; do
       TOK="$e$TOK"
     done
     ENDLBA=$(( 0x$TOK ))
     #echo "startlba='$STARTLBA'  endlba='$ENDLBA'"
     line2=$(echo "$GPTHDRCONTAINER" |  /bin/busybox grep "00000030" 2>/dev/null)
     FLAG=${line2:10:13}
     TOK=""
     for s in $FLAG; do
       TOK="$s$TOK"
     done
     FLAG=$(( 0x$TOK ))
     case $FLAG in 
       0)
	  #echo "System partition (disk partitioning utilities must preserve the partition as is) $MAINDEV$counter"
          assign_specified_partition_parameters  "$MAINDEV$counter" "$STARTLBA" "$ENDLBA" "$FS"
       ;;
       2)
          #echo "EFI firmware should ignore the content of the partition and not try to read from it $MAINDEV$counter"
	  :
       ;;
       4)
          #echo "Legacy BIOS bootable (equivalent to active flag of the MBR partition table)  $MAINDEV$counter"
          assign_specified_partition_parameters  "$MAINDEV$counter" "$STARTLBA" "$ENDLBA" "$FS"
       ;;
     esac    
     #echo $FLAG
     FLAG=${line2:24:13}
     TOK=""
     for s in $FLAG; do
       TOK="$s$TOK"
     done
     FLAG=$(( 0x$TOK ))
     case $FLAG in 
        268435456)
         	#echo "Read-only: This partition is flagged read-only "
          assign_specified_partition_parameters  "$MAINDEV$counter" "$STARTLBA" "$ENDLBA" "$FS"
       ;;
       1073741824)
          #echo ""
          :
       ;;
       2147483648)
          #echo "Hidden Flag: The partition does not appear for regular OS use."
          assign_specified_partition_parameters  "$MAINDEV$counter" "$STARTLBA" "$ENDLBA" "$FS"
       ;;
     esac    
     #echo $FLAG
     
    elif [ "$line1" = "$NILLINE" ]; then
      # break scan anyway after 14 empty GPT-headers 
      if [ $(( $cnt - $counter )) -gt 16 ]; then break; fi  
    fi
  done
  #
}
#
assign_gpt_partition_mainheader()
{
  local DEVSZ PARTDEV DEV PARTDEV0 STARTSECT SECTSIZE line1 line2 TOK PTABLE GPTHDRCONTAINER
  DEV="$1"
  #PARTDEV="$(/bin/busybox basename $DEV)"
  #PARTDEV0=$PARTDEV
  STARTSECT="$2"
  SECTSIZE="$3"
  DEVSZ="$4"
  ENDSECT="$(( $DEVSZ - 1 ))"
  PTABLE=`/bin/busybox dd if=$MAINDEV bs=$SECTSIZE count=1 skip=$STARTSECT  2>/dev/null | /bin/busybox hexdump -vC  2>/dev/null `
  line1=$(echo "$PTABLE" |  /bin/busybox grep "00000000" 2>/dev/null) 
  LABELDD="$(echo "${line1:61:8}" | /bin/busybox tr -d "/\.\`\+\\" 2>/dev/null)"
  #echo $LABELDD
  if [ "$LABELDD" != "EFI PART" ]; then 
    echo "Partition Table has no valid GUUID Partition Table Descriptor !"
    echo "Expected 'EFI PART' in this examined startsector, referenced by MS-DOS Partition table"
    export PTTYPE=""
    echo "abending...."
    return 255
  else
    export PTTYPE="gpt"
    TOK=""
    TOK="PTTYPE_$PARTDEV=\"$PTTYPE\""
    eval "$TOK"
    export "PTTYPE_$PARTDEV"
    TOK=""
    TOK="LABEL_$PARTDEV=\"EFI PART\""
    eval "$TOK"
    export "LABEL_$PARTDEV"
  fi
  LABELDD="$(echo "${line1:47:11}" | /bin/busybox tr -d "/\.\`\+\\" 2>/dev/null)"
  GPTHDRSIZE=""
  for byte in $LABELDD; do
    GPTHDRSIZE="$byte$GPTHDRSIZE"
  done 
  
  GPTHDRSIZE=$(( 0x${GPTHDRSIZE} ))
  export GPTHDRSIZE
  #echo "headersize $GPTHDRSIZE"
  line1=$(echo "$PTABLE" |  /bin/busybox grep "00000030" 2>/dev/null) 
  line2=$(echo "$PTABLE" |  /bin/busybox grep "00000040" 2>/dev/null) 
  #LABELDD="$(echo "${line1:35:23} ${line2:10:23}" | /bin/busybox tr -d "/\.\`\+\\" 2>/dev/null)"
  LABELDD="${line1:35:23} ${line2:10:23}"
  #echo $LABELDD
  PUUID="$(echo $LABELDD  | /bin/busybox tr -d " /\.\`\+\\" 2>/dev/null)"
  #echo $PUUID
  PUUID=`assign_gpt_partuuid "$PUUID"`
  #echo "first assigned puuid : $PUUID"
  DISKUUID="$PUUID"
  export DISKUUID
  TOK=""
  TOK="PARTUUID_$BLKDEV=\"$DISKUUID\""
  eval "$TOK"
  export "PARTUUID_$BLKDEV"
  TOK=""
  TOK="UUID_$BLKDEV=\"\""
  eval "$TOK"
  export "UUID_$BLKDEV"
  line2=$(echo "$PTABLE" |  /bin/busybox grep "00000050" 2>/dev/null) 
  LABELDD="$(echo "${line2:10:12}" | /bin/busybox tr -d "/\.\`\+\\" 2>/dev/null)"
  #echo $LABELDD
  TOK=""
  for byte in $LABELDD; do
    TOK="$byte$TOK"
  done
  GPTSIZE=$(( 0x$TOK ))
  export GPTSIZE

}
#
#
assign_gpt_partition()
{
  local DEVSZ PARTDEV PARTDEV0 DEV line1 line2 TOK PTABLE GPTHDRCONTAINER
  #local SSBYTE0 SSBYTE1 SSBYTE2 SSBYTE3
  #local ESBYTE0 ESBYTE1 ESBYTE2 ESBYTE3 
  local line
  if [ 0$PNUM -eq 0 ];then 
    return 127
  fi
  DEV="$1"
  #MAINDEV=$(echo $DEV | /bin/busybox tr -d [:digit:] 2>/dev/null) 
  #PARTDEV=$(/bin/busybox basename $DEV 2>/dev/null)
  DEVSZ=`/bin/busybox blockdev --getsz $MAINDEV 2>/dev/null`
  #PARTDEV0=$(/bin/busybox basename $MAINDEV 2>/dev/null)
  #PNUM=$(echo $DEV | /bin/busybox tr -d "\/[:alpha:]" 2>/dev/null) 
  PARTDEV0=$BLKDEV
  PARTDEV=$BLKDEVPART
  STARTSECT=0
  ENDSECT=0
  line1=""
  line2=""
  line=""
  TOK=""
  LABELDD=""
  line1=$(echo $DOSTABLE | /bin/busybox cut -f1   -d " " 2>/dev/null)
  line2=$(echo $DOSTABLE | /bin/busybox cut -f2   -d " " 2>/dev/null)
  #echo $line1
  #echo $line2
  if [ "$line1" != "" -a  "$line2" = "00000000000000000000000000000000" ]; then
      TOK=""
      for i in 16 18 20 22; do
         TOK="${line1:$i:2}$TOK"
         #echo $TOK $i ${line1:$i:2}
      done
      TOK=$(echo $TOK | /bin/busybox tr -d " " 2>/dev/null)
      #echo "startsect $TOK"
      STARTSECT=$(( 0x$TOK ))
      TOK=""
      for i in 24 26 28 30; do
         TOK="${line1:$i:2}$TOK"
         #echo $TOK
      done
      TOK=$(echo $TOK | /bin/busybox tr -d " " 2>/dev/null)
      #echo "endsect $TOK"
      ENDSECT=$(( 0x$TOK ))
      #echo "Startsector of partition $PNUM : $STARTSECT"
      #echo "Endsector   of partition $PNUM : $ENDSECT"
    if [ $DEVSZ -ne $(( $ENDSECT + 1 )) ]; then 
      echo "Device size $DEVSZ for $MAINDEV is not matching with endsector number of GPT !"
      echo "abending...."
      return 255
    fi
  else
     echo "Partition has Filesystem '$FS' but no valid MBR contents for a GPT !"
     echo "abending...."
    return 255
  fi
  # read the next sector after the startsector, that should contain the GPT-MBR
  PTABLE=`/bin/busybox dd if=$MAINDEV bs=$SECTSIZE skip=$STARTSECT count=1 2>/dev/null | /bin/busybox hexdump -C   2>/dev/null`
  #line1=`echo "$PTABLE" | /bin/busybox hexdump -C   2>/dev/null`
  #echo "$PTABLE"
  line1=$(echo "$PTABLE" |  /bin/busybox grep "00000000" 2>/dev/null) 
  LABELDD="$(echo "${line1:61:8}" | /bin/busybox tr -d "/\.\`\+\\" 2>/dev/null)"
  #echo $LABELDD
  if [ "$LABELDD" != "EFI PART" ]; then 
    echo "Partition Table has no valid GUUID Partition Table Descriptor !"
    echo "Expected 'EFI PART' in this examined startsector, referenced by MS-DOS Partition table"
    export PTTYPE=""
    echo "abending...."
    return 255
  else
    export PTTYPE="gpt"
    TOK=""
    TOK="PTTYPE_$PARTDEV=\"$PTTYPE\""
    eval "$TOK"
    export "PTTYPE_$PARTDEV"
  fi
  LABELDD="$(echo "${line1:47:11}" | /bin/busybox tr -d "/\.\`\+\\" 2>/dev/null)"
  GPTHDRSIZE=""
  for byte in $LABELDD; do
    GPTHDRSIZE="$byte$GPTHDRSIZE"
  done 
  
  GPTHDRSIZE=$(( 0x${GPTHDRSIZE} ))
  export GPTHDRSIZE
  #echo "headersize $GPTHDRSIZE"
  line1=$(echo "$PTABLE" |  /bin/busybox grep "00000030" 2>/dev/null) 
  line2=$(echo "$PTABLE" |  /bin/busybox grep "00000040" 2>/dev/null) 
  LABELDD="$(echo "${line1:35:23} ${line2:10:23}" | /bin/busybox tr -d "/\.\`\+\\" 2>/dev/null)"
  #echo $LABELDD
  PUUID="$(echo $LABELDD  | /bin/busybox tr -d " " 2>/dev/null)"
  #echo $PUUID
  PUUID=`assign_gpt_partuuid "$PUUID"`
  #echo "first assigned puuid : $PUUID"
  DISKUUID="$PUUID"
  export DISKUUID
  TOK=""
  TOK="PARTUUID_$PARTDEV0=\"$DISKUUID\""
  eval "$TOK"
  export "PARTUUID_$PARTDEV0"
  line2=$(echo "$PTABLE" |  /bin/busybox grep "00000050" 2>/dev/null) 
  LABELDD="$(echo "${line2:10:12}" | /bin/busybox tr -d "/\.\`\+\\" 2>/dev/null)"
  #echo $LABELDD
  TOK=""
  for byte in $LABELDD; do
    TOK="$byte$TOK"
  done
  GPTSIZE=$(( 0x$TOK ))
  GPTHDRID="af 3d c6 0f 83 84 72 47  8e 79 3d 69 d8 47 7d e4"
  EFIID="c1 2a 73 28 f8 1f 11 d2  ba 4b 00 a0 c9 3e c9 3b"
  EFIID2="28 73 2a c1 1f f8 d2 11  ba 4b 00 a0 c9 3e c9 3b"
  EFIHDRID="  ba 4b 00 a0 c9 3e c9 3b"
  NILLINE="00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|"
  GPTHDRCONTAINER=""
  start=2
  counter=0
  if [ "$PNUM" != "" ];then
  for cnt in `seq 0 127`; do 
    GPTHDRCONTAINER=`/bin/busybox dd if=$MAINDEV bs=$GPTSIZE skip=$(( $start + $cnt )) count=1 2>/dev/null | /bin/busybox hexdump -C 2>/dev/null`
    line1=$(echo "$GPTHDRCONTAINER" |  /bin/busybox grep "00000000" 2>/dev/null)
    #echo "counter=$counter"
    #echo "$GPTHDRCONTAINER"
    if `is_substring_of "$GPTHDRID " "$line1 "` || `is_substring_of "$EFIHDRID " "$line1 "`; then 
      counter=$(( $counter + 1 ))
    
      if [ $counter -eq $PNUM ]; then 
       #echo "partitionheader no. $counter at $(( $GPTSIZE * $(( $start + $cnt )) ))"
       #echo "$GPTHDRCONTAINER"
       line2=$(echo "$GPTHDRCONTAINER" |  /bin/busybox grep "00000010" 2>/dev/null)
       PARTUUID=${line2:10:48}
       PARTUUID=$(echo $PARTUUID | /bin/busybox tr -d " " 2>/dev/null)
       #echo "$PARTUUID"
       PARTUUID=`assign_gpt_partuuid "$PARTUUID"`
       TOK=""
       TOK="PARTUUID_$PARTDEV=\"$PARTUUID\""
       eval "$TOK"
       export "PARTUUID_$PARTDEV"
       echo "Partuuid for $PARTDEV ='$PARTUUID'"
       #export
       line2=$(echo "$GPTHDRCONTAINER" |  /bin/busybox grep "00000020" 2>/dev/null)
       STARTLBA=${line2:10:23}
       ENDLBA=${line2:35:23}
       #echo "startlba='$STARTLBA'  endlba='$ENDLBA'"
       TOK=""
       for s in $STARTLBA; do
         TOK="$s$TOK"
       done
       STARTLBA=$(( 0x$TOK ))
       TOK=""
       for e in $ENDLBA; do
         TOK="$e$TOK"
       done
       ENDLBA=$(( 0x$TOK ))
       #echo "startlba='$STARTLBA'  endlba='$ENDLBA'"
       line2=$(echo "$GPTHDRCONTAINER" |  /bin/busybox grep "00000030" 2>/dev/null)
       FLAG=${line2:10:13}
       TOK=""
       for s in $FLAG; do
         TOK="$s$TOK"
       done
       FLAG=$(( 0x$TOK ))
       case $FLAG in 
         0)
            #echo "System partition (disk partitioning utilities must preserve the partition as is)"
            assign_specified_partition_parameters  "$MAINDEV$counter" "$STARTLBA" "$ENDLBA" "$FS"
         ;;
         2)
            #echo "EFI firmware should ignore the content of the partition and not try to read from it"
            :
         ;;
         4)
            #echo "Legacy BIOS bootable (equivalent to active flag (typically bit 7 set) at offset +0h in partition entries of the MBR partition table)"
            assign_specified_partition_parameters  "$MAINDEV$counter" "$STARTLBA" "$ENDLBA" "$FS"
         ;;
       esac    
       #echo $FLAG
       FLAG=${line2:24:13}
       TOK=""
       for s in $FLAG; do
         TOK="$s$TOK"
       done
       FLAG=$(( 0x$TOK ))
       case $FLAG in 
          268435456)
            #echo "Read-only: This partition is flagged read-only "
            assign_specified_partition_parameters  "$MAINDEV$counter" "$STARTLBA" "$ENDLBA" "$FS"
         ;;
         1073741824)
            #echo ""
            :
         ;;
         2147483648)
            #echo "Hidden Flag: The partition does not appear for regular OS use."
         ;;
       esac    
       #echo $FLAG
       echo "Successfully found the partition no. '$PNUM' "
       break
      fi 
     elif [ "$line1" = "$NILLINE" ]; then
      if [ $cnt -gt 16 ]; then break; fi  
     fi
  done
  else
    echo "no partition number specified!"
  fi
  #
}
#
assign_filesystem_parameter()
{
  for line in $DOSTABLE; do
    FS=${line:8:2}
    if [ "$FS" != "00" ]; then 
      break
    fi
  done
  export FS
}
#
set_blockdev_partition_parameters()
{
  #set -x
  local DEV DEVPATH TOK line1 line2
  DEV="$1"
  if [ -e "$DEV" ]; then
    BLKDEVPART=""
    local string sysblkdev bdevs
    string="$1"
    bdevs=""
    string=`/bin/busybox readlink -f "$string" 2>/dev/null`
    BLKDEVPART=`/bin/busybox basename $string 2>/dev/null`
    MAINDEVPATH="`/bin/busybox dirname $string 2>/dev/null`"
    sysblkdev=""
    for sysblkdev in $(/bin/busybox ls -1 /sys/block 2>/dev/null); do
      case $BLKDEVPART in
        *$sysblkdev*)
          bdevs=$sysblkdev
        ;;
      esac
    done
    if [ "$bdevs" != "" ]; then 
      if [ "$bdevs" != "$BLKDEVPART" ]; then 
        BLKDEV="$bdevs"
        PNUM=`last_digits_of_string "$BLKDEVPART"`
      else
        BLKDEV="$BLKDEVPART"
        BLKDEVPART=""  
        PNUM=""
      fi
      MAINDEV="${MAINDEVPATH}/${BLKDEV}"
      export BLKDEVPART BLKDEV PNUM MAINDEV MAINDEVPATH
    fi
    echo "maindev $MAINDEV "
    if [ 0$PNUM -gt 128 ]; then
        return 255
    elif [ 0$PNUM -eq 0 ]; then
        return 127
    fi  
    SECTSIZE=`/bin/busybox blockdev --getss "$MAINDEV" 2>/dev/null`
    if [ "$SECTSIZE" = "" ]; then 
      SECTSIZE=512
    fi
    export SECTSIZE
    BLKSIZE=`/bin/busybox blockdev --getbsz "$MAINDEV" 2>/dev/null`
    if [ "$BLKSIZE" = "" ]; then 
      BLKSIZE=$SECTSIZE
    fi
    export BLKSIZE
    read_msdos_partitiontable $MAINDEV
    if [ $? -eq 0 ];then 
      assign_filesystem_parameter
      case $FS in
         ee|ef)
           echo "assigning gpt table"
           assign_guuid_partition "$DEV"
         ;;
         00)
           : 
           #  empty MBR means that there are no partition parameters to assign
         ;;
         *)
           echo "assigning msdos table"
           assign_msdos_partition "$DEV"
         ;;
      esac
    else
      return 127
    fi
  else
    return 127
  fi
}
#
set_blockdev_parameters()
{
  #set -x
  local DEV PNUM PARTDEV PARTDEV00 DEVPATH BLOCKDEVICES RC
  DEV="$1"
  PARTDEV=""
  PARTDEV00=""
  DEVPATH=""
  STARTSECT=""
  ENDSECT=""
  line1=""
  line2=""
  TOK=""
  PNUM=""
  PARTDEV="`/bin/busybox basename ${DEV} 2>/dev/null`"
  MAINDEV=`assign_devpath_string "$DEV"`
  RC=$?
  #if ! `assign_devpath_string "$DEV"`; then
  if [ 0$RC -ne 0 ]; then
    echo "errors in main device specifier string '$DEV' ....."
    return 127
  fi 
  #MAINDEVPATH="`/bin/busybox dirname $DEV 2>/dev/null`"
  #MAINDEV=$MAINDEVPATH/$PARTDEV
  #echo MAINDEV $MAINDEV
  SECTSIZE=`/bin/busybox blockdev --getss ${MAINDEV} 2>/dev/null`
  export SECTSIZE
  read_msdos_partitiontable "$MAINDEV" 
  RC=$?
  if [ $RC -eq 0 ]; then
    #echo "read table: $DOSTABLE, sectorsize: $SECTSIZE, assigning : $MAINDEV $FS"
    assign_filesystem_parameter
    case $FS in
       ee|ef)
         assign_gpt_partitiontable "$MAINDEV"
       ;;
       00)
         : 
         #  empty MBR means that there are no partition parameters to assign
       ;;
       *)
         assign_msdos_partitiontable "$MAINDEV"
       ;;
    esac
  fi
  #set +x
  return $RC
}
#
assign_ebrtable_entries()
{
    local BOOTPT counter DISKPNUM DEV line
    DISKPNUM=1
    counter=0
    EBR="$1"
    DEV="$2"
    PARTDEV=$(/bin/busybox basename $DEV 2>/dev/null2)
    for line in $EBRENTRIES; do
      if [ "$line" != "00000000000000000000000000000000" ]; then
        counter=$(( $counter + 1 ))
        BOOTPT=${line:0:1}
        #echo BOOTABLE $BOOTPT
        TOK=""
        for i in 16 18 20 22; do
           TOK="${line:$i:2}$TOK"
        done
        #TOK=$(echo $TOK | /bin/busybox tr -d " " 2>/dev/null)
        STARTSECT=$(( 0x$TOK ))
        TOK=""
        for i in 24 26 28 30 ; do
           TOK="${line:$i:2}$TOK"
        done
        #TOK=$(echo $TOK | /bin/busybox tr -d " " 2>/dev/null)
        LENSECT=$(( 0x$TOK ))
        #echo "Startsector of partition       $PNUM : $STARTSECT"
        ENDSECT=$(( $STARTSECT + $LENSECT - 1 ))
        #echo "Endsector  of partition        $PNUM : $ENDSECT"
        #echo "Length in Sectors of partition $PNUM : $LENSECT"
        #echo "Length in Bytes   of partition $PNUM : $(( $LENSECT * $SECTSIZE ))"
        #echo "Length in KiBytes of partition $PNUM : $(( $LENSECT * $SECTSIZE / $KB ))"
        #echo "Length in MiBytes of partition $PNUM : $(( $LENSECT * $SECTSIZE / $MB ))"
        #echo "Length in GiBytes of partition $PNUM : $(( $LENSECT * $SECTSIZE / $GB ))"
        assign_array_variable "STARTSECTOR_"  "$PARTDEV$counter" "$STARTSECT"
        assign_array_variable "ENDSECTOR_"    "$PARTDEV$counter" "$ENDSECT"
        assign_array_variable "SECTORLENGTH_" "$PARTDEV$counter" "$LENSECT"
        FS=${line:8:2}
        #echo FS $FS
        case $FS in
          ee|ef)
            assign_guuid_partition_mainheader "$DEV" "$STARTSECT" "$SECTSIZE" "$LENSECT"
          ;;
          00)
            :
          ;;
          *)
            TOK="PARTUUID_"
            TOK="$TOK$PARTDEV$DISKPNUM=\"${PUUID}-0${DISKPNUM}\""
            #echo "TOK=$TOK"
            eval "$TOK"
            export $TOK
            assign_array_variable "PARTUUID_"  "$PARTDEV$counter" "${PUUID}-0${DISKPNUM}"
            #export "PARTUUID_$PARTDEV"
          ;;
        esac
      fi
      DISKPNUM=$(( $DISKPNUM + 1 ))
    done
}
#
#
read_ebr()
{
  local DISKID PTABLE WORD1 WORD2 SS PART1 PART2 PART3 PART4 PARTITIONS
  local DEV PARTDEV PARTDEV00 DISKPNUM TOK STARTSECT LENSECT
  if [ -e "$1" ]; then
    DEV="$1"
    PARTDEV=""
    DEVPATH=""
    STARTSECT=0
    LENSECT=0
    ENDSECT=0
    TOK=""
    DISKPNUM=""
    MAINDEV=`assign_devpath_string "$DEV"`
    RC=$?
    #if ! `assign_devpath_string $DEV`; then 
    if [ 0$RC -ne 0 ]; then
       echo " device and partition name not recognizable:"
       echo " maindev $MAINDEV maindevpath $MAINDEVPATH pnum $PNUM blkdev $BLKDEV blkdevpart $BLKDEVPART "
    fi
    SECTSIZE=`/bin/busybox blockdev --getss "$MAINDEV" 2>/dev/null`
    if [ "$SECTSIZE" = "" ]; then 
      SECTSIZE=512
    fi
    export SECTSIZE
    BLKSIZE=`/bin/busybox blockdev --getbsz "$MAINDEV" 2>/dev/null`
    if [ "$BLKSIZE" = "" ]; then 
      BLKSIZE=$SECTSIZE
    fi
    PARTUUID=""
    PUUID=""
    PTABLE=`/bin/busybox dd if=$1   bs=512 count=1 skip=0  2>/dev/null | /bin/busybox hexdump -vC  2>/dev/null | /bin/busybox cut -c 11-60 | /bin/busybox tr -d " \n" 2>/dev/null`
     # read the four bytes of ms-dos partuuid and store it as 8 byte hex number in correct format
    DISKID=${PTABLE:880:8}
    #echo DISKID $DISKID
    if [ "$DISKID" != "00000000" ]; then
      PUUID=""
      # reorder the words containing the partuuid
      for i in 0 2 4 6; do
        PUUID="${DISKID:$i:2}$PUUID"
      done
      #echo PUUID $PUUID
      PARTUUID=$PUUID
      export PUUID PARTUUID
    fi
    PARTITIONS=${PTABLE:892:128}  
    # set the partition parameters
    EBRENTRIES="${PTABLE:892:32} ${PTABLE:924:32} ${PTABLE:956:32} ${PTABLE:988:32}"
    #echo EBRENTRIES $EBRENTRIES
    export EBRENTRIES
    PARTITIONS=""
    counter=0
    for line in $EBRENTRIES; do
      if [ "$line" != "00000000000000000000000000000000" ]; then
        counter=$(( $counter + 1 ))
      fi
    done
    if [ $counter -eq 0 ]; then 
      # examine the first 32768 bytes of the blockdev
      MBRENDOFFSETS=""
      PTABLE=`/bin/busybox dd if=$1   bs=4096 count=8 skip=0  2>/dev/null | /bin/busybox hexdump -vC  2>/dev/null`
      MBRENDOFFSETS=`echo "$PTABLE" | /bin/busybox grep "55 aa  |" 2>/dev/null | /bin/busybox cut -c 1-8 2>/dev/null`
      #if [ `echo "$MBRENDOFFSETS" | /bin/busybox wc -l 2>/dev/null` -gt 0  ]; then 
      # faster and simpler
      if [  "$MBRENDOFFSETS" != ""  ]; then 
        OFFSETS=""
        for offs in $MBRENDOFFSETS; do
          offs=$(( 0x$offs ))
          offs=$(( $offs - 496 ))
          OFFSETS="$offs $OFFSETS"
        done
        PT=`echo "$PTABLE" | /bin/busybox cut -c 11-60 2>/dev/null | /bin/busybox tr -d " \n" 2>/dev/null` 
        for offs in $OFFSETS; do
          EBRENTRIES="${PT:$(( 892 + $offs)):32} ${PT:$(( 924 + $offs )):32} ${PT:$(( 956 + $offs )):32} ${PT:$(( 988 + $offs )):32}"
          export EBRENTRIES
          counter=0
          for line in $EBRENTRIES; do
            if [ "$line" != "00000000000000000000000000000000" ]; then
              counter=$(( $counter + 1 ))
            fi
          done
          if [ $counter -eq 0 ]; then 
            # skip the first Megabyte and examine the following 32768 bytes of the blockdev
            PTABLE=`/bin/busybox dd if=$1   bs=4096 count=8 skip=256  2>/dev/null | /bin/busybox hexdump -vC  2>/dev/null`
            MBRENDOFFSETS=`echo "$PTABLE" | /bin/busybox grep "55 aa  |" 2>/dev/null | /bin/busybox cut -c 1-8 2>/dev/null`
            if [ `echo "$MBRENDOFFSETS" | /bin/busybox wc -l 2>/dev/null` -gt 0  ]; then 
              OFFSETS=""
              for offs in $MBRENDOFFSETS; do
                offs=$(( 0x$offs ))
                offs=$(( $offs - 496 ))
                OFFSETS="$offs $OFFSETS"
              done
              PT=`echo "$PTABLE" | /bin/busybox cut -c 11-60 2>/dev/null | /bin/busybox tr -d " \n" 2>/dev/null` 
              for offs in $OFFSETS; do
                EBRENTRIES="${PT:$(( 892 + $offs)):32} ${PT:$(( 924 + $offs )):32} ${PT:$(( 956 + $offs )):32} ${PT:$(( 988 + $offs )):32}"
                export EBRENTRIES
                counter=0
                for line in $EBRENTRIES; do
                  if [ "$line" != "00000000000000000000000000000000" ]; then
                    counter=$(( $counter + 1 ))
                  fi
                done
                if [ $counter -ne 0 ]; then 
                  assign_ebrtable_entries "EBRENTRIES"  "$MAINDEV"
                fi
              done
            fi
            break
          else
             assign_ebrtable_entries "EBRENTRIES"  "$MAINDEV"
          fi
        done
      else
        assign_ebrtable_entries "EBRENTRIES" "$MAINDEV"
      fi
      
    else
      #echo "assigning $EBRENTRIES"
      assign_ebrtable_entries "EBRENTRIES" "$MAINDEV"
    fi
    
    return 0
  fi
  return 127
}
#
#
read_msdos_partitiontable()
{
    local DISKID PTABLE WORD1 WORD2  PART1 PART2 PART3 PART4
    if [ "$1" != "" ]; then 
      if [ -e  "$1" ]; then
	DISKPUUID=""
	PUUID=""
	DOSTABLE=`/bin/busybox dd if=$1 bs=1 count=64 skip=446  2>/dev/null | /bin/busybox hexdump -vC  2>/dev/null | /bin/busybox cut -c 11-60 2>/dev/null | /bin/busybox  tr -d " " 2>/dev/null | /bin/busybox tr "\n" " " 2/dev/null `
	#echo DOSTABLE $DOSTABLE
	export DOSTABLE
	#export FS=${DOSTABLE:8:2}
	#echo $FS
	WORD1=""
	WORD2=""
	 # read the four bytes of ms-dos partition uuid and store it as 8 byte hex number in correct format
	DISKID=`/bin/busybox dd if=$1 bs=1 count=4 skip=440  2>/dev/null | /bin/busybox hexdump  2>/dev/null`
	if [ $? -eq 0 -a "$DISKID" != "" ]; then
	  PUUID=""
	  # reorder the words containing the partuuid
	  WORD1=${DISKID:8:4}
	  WORD2=${DISKID:13:4}
	  PUUID="$WORD2$WORD1"
	fi
	#echo $PUUID
	DISKPUUID=$PUUID
	export PUUID DISKPUUID
	return 0
      fi
    fi
    DISKPUUID=""
    PUUID=""
    DOSTABLE=""
    FS=""
    export FS DISKPUUID DOSTABLE PUUID
    return 127
}
#
#
set_disk_parameters()
{
  #set -x
  local DEV PARTDEV NEWPARTDEVS PDEVS
  DEV=""
  PARTDEV=""
  BLOCKDEVPARTS=""
  PARTDEVS=""
  #BLOCKDEVS="`/bin/busybox ls -1d  /sys/block/hd*/hd*  /sys/block/sd*/sd* /sys/block/sr*/sr* /sys/block/sr* /sys/block/scd*/scd*  /sys/block/mmc*/mmc* 2>/dev/null | /bin/busybox tr "\n" " " 2>/dev/null`"
  BLOCKDEVS="`/bin/busybox ls -1d /sys/block/* 2>/dev/null | /bin/busybox tr "\n" " " 2>/dev/null`"
  for DEV in $BLOCKDEVS; do
    PARTDEV="`/bin/busybox basename $DEV 2>/dev/null`"
    NEWPARTDEVS="`/bin/busybox ls -1d $DEV/$PARTDEV* 2>/dev/null | /bin/busybox tr "\n" " " 2>/dev/null`"
    if [ "$NEWPARTDEVS" != "" ]; then 
      PDEVS=""
      for pdev in $NEWPARTDEVS; do 
        PDEVS="$PDEVS $(/bin/busybox basename $pdev 2>/dev/null)"
      done
      PARTDEVS="$PARTDEVS $PARTDEV"
      BLOCKDEVPARTS="$BLOCKDEVPARTS $PDEVS"
    fi
  done 
  export PARTDEVS BLOCKDEVPARTS BLOCKDEVS="$BLOCKDEVPARTS"
  for DEV in $PARTDEVS; do 
    set_blockdev_parameters /dev/$DEV
  done 
  #BLOCKDEVS="`/bin/busybox ls -1d /sys/block/hd* /sys/block/sd* /sys/block/mmc* /sys/block/sr* /sys/block/scd*  2>/dev/null | /bin/busybox tr "\n" " " 2>/dev/null`"
  #for DEV in $BLOCKDEVS ; do
  #  PARTDEV="`/bin/busybox basename $DEV 2>/dev/null`"
  #  PARTDEVS="$PARTDEVS $PARTDEV"
  #  set_blockdev_parameters /dev/$PARTDEV
  #done 
}
#
is_accessible_blockdevice()
{
  # the device must exist and is checked for blockdev property and read-accessibility with dd applet from BusyBox
  local DEVTREE RDEV SYSBLK rootdev sysblkdev sysdev dev PART
  rootdev=""
  sysblkdev=""
  sysdev=""
  RDEV=""
  if [ "$1" != "" ]; then
    RDEV="$1"
  else
    return 127
  fi  
  sysblkdev="$1"
  dev=""
  SYSBLK="$(/bin/busybox basename $sysblkdev 2>/dev/null)"
  SYSBLKDEV1=""
  SYSBLKDEV2=""
  SYSBLKDEV1=$(/bin/busybox ls -1d /sys/block/$SYSBLK 2>/dev/null)
  SYSBLKDEV2=$(/bin/busybox ls -1d /sys/block/*/$SYSBLK* 2>/dev/null)
  if [ "$SYSBLKDEV1" != "" -o "$SYSBLKDEV2" != "" ]; then
    if [ "$(/bin/busybox ls -1 "$RDEV" 2>/dev/null)" = "$RDEV" ]; then
      rootdev=found
    fi
    if [ -e $sysblkdev ]; then
      sysdev=found
    fi
  else
    return 1
  fi
  PART=""
  RC=5
  if [ "$sysdev" != "" -a "$rootdev" != ""  ]; then
    # can I read from the required device?
    #  8 * 512 = 4096 is unifying combination for 512 bytes and 4096 bytes blocksized disks
    PART=$(/bin/busybox dd if=$sysblkdev  bs=512 count=8  skip=0 2>/dev/null)
    RC=$?
    if [ "$PART" != "" ]; then 
      if [ $RC -ne 0 ]; then
        echoconsole "[ $0 ]:" "Error in reading from blockdevice '$1' : '$RC', but got read some data"
      fi
      return 0
    else
      echoconsole "[ $0 ]:" "dd Error:'$RC' , Cannot read the first 4KB from blockdevice '$1' "
      return 1
    fi
  else 
    return 1
  fi
}
#
verify_ptable()
{
  if [ "$PTABLE" != "" ]; then
     # TODO: check partition table consistency
     return 0
  else
     return 1
  fi
}
# version 0.5
recognize_rootdevice()
{
  local var cnt BLKID DEVNUM THEDEV DEVBOOT DEVROOT DEVROOT1 DEVROOT2 TOEVAL L
  var=""
  BLKID=""
  DEVBOOT=""
  DEVROOT=""
  DEVROOT1=""
  DEVROOT2=""
  TOEVAL=""
  L=""
  #set -x
  if [ "$ROOTDEV" != "" ]; then
    # ROOTDEV must have the LABEL= UUID= PARTUUID= specification  
    if [ "$PARTUUID_ROOT" != "" ]; then
        #must be done before !!!!  inline_external_file "blockdevice-functions"
	set_disk_parameters
	for THEDEV in $BLOCKDEVPARTS; do
	  L=`display_array_variable "PARTUUID_" "$THEDEV"`
	  #var="PARTUUID_$THEDEV"
	  #TOEVAL="L=\$$var"
	  #eval  $TOEVAL 
	  if [ "$L" = "$PARTUUID_ROOT" ]; then
	    DEVROOT="/dev/$THEDEV"
	    break
	  fi
	done
	#DEVROOT=`get_blockdev_from_partuuid  "$PARTUUID"`
        
	if [ "$DEVROOT" != "" ]; then
          export ROOTDEV="$DEVROOT"
	  return 0
        fi        
    else
      case $ROOTDEV in
	LABEL=\"*\")
	  DEVROOT=`/bin/busybox findfs LABEL="$LABEL" 2>/dev/null`
	  if [ "$DEVROOT" = "" ]; then
	     DEVROOT=`/bin/busybox findfs LABEL=$LABEL 2>/dev/null`
	  fi
	;;
	LABEL=*)
	  DEVROOT=`/bin/busybox findfs LABEL="$LABEL" 2>/dev/null`
	  if [ "$DEVROOT" = "" ]; then
	     DEVROOT=`/bin/busybox findfs LABEL=$LABEL 2>/dev/null`
	  fi
	;;
	UUID=*)
	  DEVROOT=`/bin/busybox findfs UUID=$UUID 2>/dev/null`
	;;
      esac
      #DEVROOT=`/bin/busybox findfs "$ROOTDEV" 2>/dev/null`
      if [ "$DEVROOT" != "" ]; then
	export ROOTDEV="$DEVROOT"
	return 0
      fi
    fi
    if [ "$DEVROOT" = "" ]; then
      if [ "$DISKID" != "" ]; then
        DEVROOT=`get_blockdev_from_diskid  "$DISKID"`
        if [ "$DEVROOT" != "" ]; then
          export ROOTDEV="$DEVROOT"
        fi                
      fi
      if [ "$PATHID" != "" ]; then
        DEVROOT=`get_blockdev_from_pathid  "$PATHID"`
        if [ "$DEVROOT" != "" ]; then
          export ROOTDEV="$DEVROOT"
        fi                
      fi
      if [ "$LABEL" != "" ]; then
        DEVROOT1=`/bin/busybox findfs LABEL="$LABEL" 2>/dev/null`
        if [ "$DEVROOT1" != "" ]; then
          DEVROOT1=`/bin/busybox findfs LABEL=$LABEL 2>/dev/null`
	fi
      fi
      if [ "$UUID" != "" ]; then
        DEVROOT2=`/bin/busybox findfs UUID="$UUID" 2>/dev/null`
      fi
      if [ "$DEVROOT1" != "" -a "$DEVROOT2" != "" ]; then
        if [ "$DEVROOT1" != "$DEVROOT2" ]; then
          echoconsole "$INITPREF"  "Warning: Specified UUID and LABEL do not match the same device! "
          [ "$DEVROOT1" != "" ] && DEVROOT="$DEVROOT1" && echoconsole "$INITPREF"  "Warning: Using block device, recognized with LABEL, is not necessarily unique !"        
          [ "$DEVROOT2" != "" ] && DEVROOT="$DEVROOT2" && echoconsole "$INITPREF"  "Warning: Preferring to use the UUID specified device before LABEL !"        
        else
          DEVROOT="$DEVROOT2"
          export ROOTDEV="$DEVROOT"          
	  return 0
        fi
      else
        if [ "$DEVROOT1" != "" ]; then
          DEVROOT="$DEVROOT1"
          export ROOTDEV="$DEVROOT"          
	  return 0
        fi
        if [ "$DEVROOT2" != "" ]; then
          DEVROOT="$DEVROOT2"
          export ROOTDEV="$DEVROOT"          
	  return 0
        fi
      fi
    fi
    
  else # rootdev=""
    return 5
  fi  # rootdev
  #set +x
}
#
verify_rootdevice()
{
  local var  PARTDEV
  if [ -e $ROOTDEV ]; then
    if [ "$ROOTDEV" = "$ROOT" ]; then
      if [ "$LABEL" = "" ]; then
        PARTDEV="`/bin/busybox basename "$ROOTDEV" 2>/dev/null`"
        var=LABEL_$PARTDEV
	eval "LABEL=\$$var"
	export LABEL
      fi
      if [ "$UUID" = "" ]; then
        PARTDEV="`/bin/busybox basename "$ROOTDEV" 2>/dev/null`"
        var=UUID_$PARTDEV
	eval "UUID=\$$var"
	export UUID
      fi
      if [ "$PARTUUID" = "" ]; then
	#PARTUUID=`get_partuuid_from_blockdev  $ROOTDEV 2>/dev/null`
        PARTDEV="`/bin/busybox basename "$ROOTDEV" 2>/dev/null`"
	var=PARTUUID_$PARTDEV
	eval "PARTUUID=\$$var"
	export PARTUUID
      fi
#    else
#      :
    fi
    return 0
  fi
  inline_external_file "blockdevice-functions"
  set_disk_parameters
  parse_rootdevice_string
  recognize_rootdevice
  return 1
}
#
