#
#  INIT-FUNCTIONS for Universal INIT with busybox
#  (C) Dieter Miosga , 2008-2015-10-09, dmiosga6200@gmail.com 
#
#set -x
#DELAY=delay
#
create_rootfs_dirs()
{
   local DIRS ARG
   if [ "$SYSTEMDIRECTORIES" != "" ]; then
     DIRS="$SYSTEMDIRECTORIES"
     export SYSTEMDIRECTORIES
   else
     DIRS="dev dev/input dev/usb dev/net dev/shm dev/pts dev/fd dev/block dev/disk etc etc/sysconfig etc/init.d etc/rc.d  etc/udev memory union root run sys proc bin sbin usr lib lib/modules lib/libexec tmp mnt var opt usr/bin usr/sbin usr/lib usr/libexec usr/share usr/local usr/local/bin usr/local/sbin usr/local/lib usr/local/libexec usr/local/share var/lock var/log var/run usr/share bbsymlinx"
   fi

  for ARG in $DIRS; do
   #[ -d $1/$ARG ] || /bin/busybox mkdir -p $1/$ARG  2>/dev/null
   /bin/busybox mkdir -p $1/$ARG  2>/dev/null
  done

}
#
build_rootfs()
{
  /bin/busybox mkdir -p -m 0755 /dev
  /bin/busybox mkdir -p -m 0700 /root
  [ -e /dev/console ] || /bin/busybox  mknod -m 0700 /dev/console c 5 1
  [ -e /dev/null ]    || /bin/busybox  mknod /dev/null c 1 3
  > /dev/.initramfs-tools
  /bin/busybox mkdir -p /dev/.initramfs
  #create_rootfs_dirs ""
  
}
#
bbversion_check()
{
  local BBVER BBMAXVER BBMINVER
  BBMINVER=""
  BBMAXVER=""
  BBVER=""
  BBVER=$(/bin/busybox --help 2>/dev/null)
  # version with creation date
  BBVER=${BBVER:9:37}
  if [ "$BBVER" != "" ]; then
    BBMAXVER=${BBVER//.*}
    BBVER=${BBVER#*.}
    BBMINVER=${BBVER//.*}
    if [ $BBMINVER -lt 18 -o $BBMAXVER -lt 1 ]; then  
      export ECHOTEXT="$ECHOTEXT
  $INITPREF Wrong version $BBVER of BusyBox , must be greater or equal 1.18!"
      SYSERRPROMPT=yes
      echo "$ECHOTEXT"
      error2ash "fatal version error for busybox executable"
      return 1
    fi
    return 0
  else
      export ECHOTEXT="$ECHOTEXT
  $INITPREF Fatal configuration error for BusyBox , cannot read correctly system version !"
      SYSERRPROMPT=yes
      echo "$ECHOTEXT"
      error2ash "fatal error for busybox executable"
      return 1
  fi
}
#
bbapplets_check()
{
  if [ "$MINIMAL_YAINIT_BBALIASES" != "" ]; then
    local applet ALLBBAPPLETS RC
    ALLBBAPPLETS=""
    ALLBBAPPLETS=`/bin/busybox --list 2>/dev/null | /bin/busybox tr "\n" " " 2>/dev/null`
    applet=""
    if [ "$ALLBBAPPLETS" != "" ]; then
      for applet in $MINIMAL_YAINIT_BBALIASES; do
        if `is_not_substring_of " $applet " " $ALLBBAPPLETS "`; then
          export ECHOTEXT="$ECHOTEXT
$INITPREF Applet '$applet' not found in preconfigured BusyBox-Applets! "
          SYSERRFATAL=yes
          echo "$ECHOTEXT"
          error2ash "fatal configuration error for busybox executable"
          return 1
        fi
      done
      export ECHOTEXT="$ECHOTEXT
$INITPREF All necessary BusyBox - Applets found ! "
      return 0
    else
      # in case of exception the more expensive way:
      for applet in $MINIMAL_YAINIT_BBALIASES; do
        RC=""
        ALLBBAPPLETS=`/bin/busybox "$applet" --help 2>/dev/null`
        RC=$?
        if  [ $RC -ne 0 ] ; then
          export ECHOTEXT="$ECHOTEXT
$INITPREF Applet '$applet' not found in well preconfigured BusyBox-Applets!"
          SYSERRFATAL=yes
          echo "$ECHOTEXT"
          error2ash "fatal configuration error for busybox executable"
          return 1
        fi
      done
      export ECHOTEXT="$ECHOTEXT
$INITPREF All necessary BusyBox - Applets found ! "
      return 0
    fi
  else 
    export ECHOTEXT="$ECHOTEXT
$INITPREF No minimal applet subset specified for BusyBox, continuing....."
    return 1
  fi
}
#
set_bbsymlinks()
{
  # now create symlinks 
  cd /bin
  /bin/busybox  --install -s
  cd /
  /bin/busybox ln -sf /bin/busybox /bin/sh  2>/dev/null
  /bin/busybox ln -sf /bin/busybox /bin/ash  2>/dev/null
  #if [ -x /bin/dash ] || [ -x /sbin/dash ]; then
  #fi 
  #if [ -e /sbin/busybox ]; then /bin/busybox rm  /sbin/busybox  2>/dev/null ;fi
  /bin/busybox sync 2>/dev/null
}
#
# optimizes any binary executable, for that a replacement with
# an extension for local processor is present 
cmdset_optimize()
{
  # $1 = calling function id, $2 = executable to optimize
  # set arch optimization variables
  if [ "$CPUINFO" = "" ]; then 
     ECHOTEXT="$ECHOTEXT
$1 No cpu information "
     export ECHOTEXT="$ECHOTEXT
$1 missing CPU information from /proc/cpuinfo - continuing with default '$2'"          
     return 1
  fi
  if [ "$MAXCMDSET" =  "" ]; then 
     ECHOTEXT="$ECHOTEXT
$1 nothing optimized (1)"
     export ECHOTEXT="$ECHOTEXT
$1 missing processor commandset information - continuing with default '$2'"
     return 1 
  fi
  #set -x     
  ECHOTEXT="$ECHOTEXT
$1 Running on a machine '$CPUMODEL'"
  export ECHOTEXT="$ECHOTEXT
$1 capable for processor instructions '$MAXCMDSET' "
  if [ "$EXTENDU" =  "" ]; then 
    ECHOTEXT="$ECHOTEXT
$1 nothing optimized (1) processor characteristics not discovered"
    export ECHOTEXT="$ECHOTEXT
$1 missing file-extension/cpu-abbreviation - continuing with default '$2'"
    return 1 
  fi
  export ECHOTEXT="$ECHOTEXT
$1 with processor specification '$EXTENDU'"
  if [ "$2" = "" ]; then 
    ECHOTEXT="$ECHOTEXT
$1 nothing optimized (5) "
    export ECHOTEXT="$ECHOTEXT
$1 missing executable specification - continuing with default"
    return 5 
  fi                                         
  local XUTABLE
  XUTABLE="$2"
  #  and install the right one version of executable  if existent
  if [ "$(/bin/busybox ls -1 $XUTABLE-$EXTENDU 2>/dev/null)" != "" ]; then  
    ECHOTEXT="$ECHOTEXT 
$1 found '$XUTABLE' and optimizing it ..."
    # save original version
    /bin/busybox cp -af $XUTABLE $XUTABLE_native  2>/dev/null
    # replace with optimized
    /bin/busybox mv  -f $XUTABLE-$EXTENDU $XUTABLE  2>/dev/null
    # save optimzed actual version
    /bin/busybox cp -af $XUTABLE-$EXTENDU $XUTABLE_optimized  2>/dev/null
    ECHOTEXT="$ECHOTEXT 
$1 ...done: optimized '$XUTABLE' for '$ARCH' architecture" 
    ECHOTEXT="$ECHOTEXT 
$1 and '$CPUMODEL' "
    export ECHOTEXT="$ECHOTEXT 
$1 with '$MAXCMDSET'  extension"
    /bin/busybox rm $XUTABLE-*  2>/dev/null
    #set +x
    return 0
  fi
  ECHOTEXT="$ECHOTEXT 
$1 nothing optimized (127)"
  export ECHOTEXT="$ECHOTEXT 
$1 '$XUTABLE-$EXTENDU' file not found, continuing with default "
  #set +x
  return 127
}
#
set_shellvariables()
{
  #  generate the variables for reading cmdline into shell variables
  # this transforms names in a variable of the form  "a b= c d="
  # to the processable variable declarations    A=$a B=$b C=$c D=$d 
  if [ "$SHELLVARIABLES" = "" ]; then
    echoconsole "$1" " Can not set variables for shell," 
    echoconsole "$1" " No variables specified in file yainitdefaults !"
    return 255
  fi
  local VAR HVAR SHELLVARNAMES TOEVAL SHELLVARSTRING
  VAR=""
  HVAR=""
  SHELLVARSTRING=""
  # check for duplicates, uppercases and nonexistent positives ( no no-prefix)
  for VAR in $SHELLVARIABLES; do
    HVAR="$(echo $VAR | /bin/busybox tr [:upper:] [:lower:] 2>/dev/null)"
    # for all NO*  parameters do truncate NO and take the rest as new parameter
    if `is_not_substring_of  " $HVAR " " $SHELLVARSTRING "`; then        
      SHELLVARSTRING="$SHELLVARSTRING $HVAR"
    fi
    # for every parameter starting with 'no', create a positive one too 
    case $HVAR in
      no*)
        #HVAR="$(echo $HVAR | /bin/busybox cut -c 3- 2>/dev/null)"
        HVAR=${VAR#no}
	if `is_not_substring_of  " $HVAR " " $SHELLVARSTRING "`; then        
           SHELLVARSTRING="$SHELLVARSTRING $HVAR"
        fi
      ;;
    esac   
  done
  
  #echo "# variables for cmdline recognition in linux shell" >> shellvars
  #echo "shellvariables $SHELLVARSTRING"
  SHELLVARNAMES=""
  TOEVAL=""
  IVAR=""
  #  root=abcde --> $root --> ROOT=$root --> echo $ROOT ==> abcde
  for VAR in $SHELLVARSTRING; do
    #HVAR="$(echo $VAR | /bin/busybox  cut -f1 -d '=' 2>/dev/null)"
    #if [ "$VAR" != "$HVAR" ]; then 
    HVAR=${VAR//=*}
    IVAR=$HVAR
    #fi
    HVAR="$(echo $IVAR | /bin/busybox tr [:lower:] [:upper:] 2>/dev/null)"
    # do not overwrite system variables presetting, only do it by commandline
    TOEVAL="TOEVAL=\$$HVAR"
    eval $TOEVAL
    if [ "$TOEVAL" = "" ]; then
      TOEVAL="$HVAR=\"\$$IVAR\""
    else
      TOEVAL="$HVAR=\$$HVAR"
    fi
    eval $TOEVAL
    #echo "$TOEVAL" #>> shellvars
    if [ "$HVAR" != "" ]; then 
      export "$HVAR"
      if `is_not_substring_of  " $HVAR " " $SHELLVARNAMES "`; then        
        SHELLVARNAMES="$SHELLVARNAMES $HVAR"
      fi
    fi
  done
  
  export ALLSHELLVARS="$SHELLVARNAMES"
  
  return 0
}
#
evaluate_shellvar_aliases()
{

  if [ "$SHELLVARALIASES" != "" ]; then
    local VAR HVAR IVAR TOEVAL KVAR
    VAR=""
    HVAR=""
    KVAR=""
    IVAR=""
  
    # evaluate aliases!
    #  nocd=nodvd --> NOCD=$NODVD (<-- NODVD=$nodvd <-- nodvd=nodvd from before) 
    for VAR in $SHELLVARALIASES; do
      #HVAR="$(echo $VAR | /bin/busybox  cut -f1 -d '=' 2>/dev/null  | /bin/busybox tr [:lower:] [:upper:] 2>/dev/null)"
      HVAR="$(echo ${VAR//=*}  | /bin/busybox tr [:lower:] [:upper:] 2>/dev/null)"
      #IVAR="$(echo $VAR  | /bin/busybox  cut -f2- -d '=' 2>/dev/null | /bin/busybox tr [:lower:] [:upper:] 2>/dev/null | /bin/busybox tr ".-" "_" 2>/dev/null)"
      IVAR="$(echo ${VAR#*=}  | /bin/busybox tr [:lower:] [:upper:] 2>/dev/null | /bin/busybox tr ".-" "_" 2>/dev/null)"
      # is $$VAR not empty? then set $HVAR
      KVAR=""
      if [ "$IVAR" != "" ];then 
        eval "KVAR=\"\$$IVAR\""
	#echo "VAR=$VAR  ,  KVAR=$KVAR"
      fi
      if [ "$KVAR" != "" ]; then
        TOEVAL="$HVAR=\"\$$IVAR\""
        #echo "$TOEVAL" #>> shellvars
        eval $TOEVAL
        export "$HVAR"
      fi
    done
    
    return 0
  else
    return 255
  fi

}
#UNARYVARS=""
#SHELLVARS=""
#
read_cmdline()
{
  # this is a function to read variables from linux kernel /proc/cmdline
  # It requires the preceding set_shellvars function to generate
  # and read in the necessary variables for the init scripts
  # The discovered unary variables in the cmdline are generated anyway
  # and will be checked for internal use according a predefinition 
  # in $SHELLVARIABLES in the variable presetting for YaIniT-init
  # and will be read into running init by the "." (source) statement.
  # The code is shortened and fastened by shrinking a necessary case statement
  # to two small sections , one for dual variables (assignments) and one for
  # special assignments with assurance of the effect of denied parameters
  # by repetitively specifying with other value (the last! validates)
  #
  # OEUVRE DE MAITRE, The ultimate solution for this problem
  # (C) Dieter Miosga <dmiosga6200@gmail.com> 2009-December-through-2016-01-01
  local ARG VAR HVAR IVAR AVAR  TOEVAL CMDLINE
  
  ARG=""
  VAR=""
  HVAR=""
  AVAR=""
  IVAR=""
  TOEVAL=""
  append=""
  #CMDLINE=" boot=LABEL=\" SYS1  EXT4 \"  `/bin/busybox  cat /proc/cmdline 2>/dev/null` root=LABEL=\"SYS01 EXT4\" last=\"off\" "
  if [ "$DEFAULT_KERNELCMDLINE_PARAMETERS" != "" ]; then 
    CMDLINE="`/bin/busybox  cat /proc/cmdline 2>/dev/null` $DEFAULT_KERNELCMDLINE_PARAMETERS"
  else
    CMDLINE="`/bin/busybox  cat /proc/cmdline 2>/dev/null`"
  fi
  ARGLINE="$CMDLINE"
  #
  for ARG in $CMDLINE; do
    # save root=* or boot=* or gernerally x=* parameters as variable assignments 
    # this is necessary for parameters specfied in bootmanager configuration file
    # and added contradictory ones by hand - to make the change active.
    
    #  eliminate dots by converting them to underscore. Dots do not work in shell variables.
    # The recognition of one or more blank in the disklabel variable e.g. as from
    #    tune2fs -L "SYS06   E4FS" /dev/sda6
    #  remains a problem, as multiple blanks are truncated to a single one
    #  The only way is to export it as soon as possible and avoid strictly
    #  eval  assignments for recalling the disklabel value.
    case $ARG in
      # assign non transient cmdline parameters a well defined variable
      # the dots in unary parameters cannot be taken in a variable name ==> "." ---> "_"
      *=*)
        IVAR=${ARG//=*}
	VAR=`echo ${IVAR}  | /bin/busybox tr [:lower:] [:upper:] 2>/dev/null | /bin/busybox tr ".-" "_" 2>/dev/null`
        HVAR=${ARG#*=}
	# is a first token of tokenized string?  yes:append next tokens as they are until end of string
	case $ARG in 
	  *=\"*)
	    append=true
	    AVAR="${ARGLINE#*=\"}"
	    AVAR="${AVAR//\"*}"
	    ARGLINE=${ARGLINE#*$IVAR=\"$AVAR\"}
	    if [ "$AVAR" = "${HVAR//\"}" ]; then
	      append=""
	    fi
	  ;;
	esac
	case $ARG in 
	  *=\'*)
	    append=true
	    AVAR="${ARGLINE#*=\'}"
	    AVAR="${AVAR//\'*}"
	    ARGLINE=${ARGLINE#*$IVAR=\'$AVAR\'}
	    if [ "$AVAR" = "${HVAR//\'}" ]; then
	      append=""
	    fi
	  ;;
	esac
	case $HVAR in 
	  *=\"*)
	    append=true
	    AVAR="${ARGLINE#*=\"}"
	    AVAR="${AVAR//\"*}"
	    HVAR=${HVAR//=*}
	    HVAR="$HVAR=\"$AVAR\""
	    ARGLINE=${ARGLINE#*$IVAR=$HVAR}
	  ;;
	esac
	case $HVAR in 
	  *=\'*)
	    append=true
	    AVAR="${ARGLINE#*=\'}"
	    AVAR="${AVAR//\'*}"
	    HVAR=${HVAR//=*}
	    HVAR="$HVAR=\'$AVAR\'"
	    ARGLINE=${ARGLINE#*$IVAR=$HVAR}
	  ;;
	esac
      ;;
      *)
         if [ "$append" != "true" ]; then
           VAR=`echo $ARG |  /bin/busybox tr [:lower:] [:upper:] 2>/dev/null | /bin/busybox tr ".-" "_" 2>/dev/null`
	   HVAR="$ARG"
	   # evaluate some special cases
	   case $VAR in
	      0|1|2|3|4|5|6|S)
		VAR=RUNLEVEL
		HVAR=$ARG
	      ;;
	      NOSWAP)
		export SWAPDEV=""
	      ;;
	      NORESUME)
		export RESUMEDEV=""
	      ;;
	      DEBUG)
		export DEBUG_IS_ENABLED="debug_is_enabled"
		export EMSG=""
	      ;;
	      QUIET)
		export VERBOSE=""
		export EMSG="2>/dev/null"
	      ;;
	      VERBOSE)
		export VERBOSE=5 
		export QUIET="" 
		export EMSG=""
	      ;;
	      RW|RO)
		export MOUNTMODE="$HVAR"
	      ;;
	      NOWAIT)
		VAR=WAIT
		HVAR=0
		wait=0
		export WAITFORROOT=0 
		export SYSWAIT=0
	      ;;
	      NONET)
		export IP="" ip="" ETH="" WLAN=""
	      ;;
	      TORAM)
		copy2ram=copy2ram
		export COPY2RAM=copy2ram
	      ;;
	   esac
	 else
	   # last token of a tokenized string
	   case $ARG in
	      *\"|*\')
		 append=""
	      ;;
	   esac
           # end skip
	   #HVAR="$HVAR $ARG"
         fi
	 
     ;;
    esac
    if [ "$append" != "true" ]; then
      # this did not work:  HVAR=$(echo $HVAR | /bin/busybox tr '\"' "\\'")
      TOEVAL="$VAR=$HVAR"
      eval   "$TOEVAL"
      export "$VAR"
    fi
  done



  if [ "$RUNLEVEL" = "" ]; then  RUNLEVEL=$DEFRUNLEVEL;  fi

  #if [ "$LOGLEVEL" = "7" ]; then DEBUG=debug; DEBUG_ENABLED=$DEBUG; fi

  # for now default logging level, switched on here


  export RUNLEVEL QUIET VERBOSE
  
#  if [ "$DEFAULT_KERNELCMDLINE_PARAMETERS" != "" ]; then 
#    for var in $DEFAULT_KERNELCMDLINE_PARAMETERS; do
#     case $var in
#	*=*)
#	  IVAR=${var//=*}
#	  HVAR=${var#*=}
#	  if [ "$IVAR$HVAR" != "" ] ; then
#	    TOEVAL="$IVAR=$HVAR"
#	    eval "$TOEVAL" 2>/dev/null
#	    export "$var"
#	  fi
#	;;
#     esac
#    done
#  fi
#
}
#
read_argline_testfunc()
{
  #
  # OEUVRE DE MAITRE, The elaborative solution for this problem
  # (C) Dieter Miosga <dmiosga6200@gmail.com> 2009-December-through-2015-10-09
  local ARG VAR HVAR IVAR AVAR TOEVAL
  
  ARG=""
  VAR=""
  IVAR=""
  AVAR=""
  HVAR=""
  TOEVAL=""
  
  for ARG in $@; do
    # save root=* or boot=* or gernerally x=* parameters as variable assignments 
    # this is necessary for parameters specfied in bootmanager configuration file
    # and added contradictory ones by hand - to make the change active.
    
    #  eliminate dots by converting them to underscore. Dots do not work in shell variables.
    echo $ARG
    case $ARG in
      # assign non transient cmdline parameters a well defined variable
      # the dots in unary parameters cannot be taken in a variable name => "." -> "_"
      #*=*=*)
#	echo DOUBLEEQUAL=$ARG
#        VAR=${ARG//=*}
#	VAR=`echo ${VAR}  | /bin/busybox tr [:lower:] [:upper:] 2>/dev/null | /bin/busybox tr ".-" "_" 2>/dev/null`
#        HVAR=${ARG#*=}
	#TOEVAL="$VAR=\"$HVAR\""
	#eval   "$TOEVAL"
	#export "$VAR"
	#echo VAR=$VAR HVAR=$HVAR
        #VAR=${HVAR//=*}
	#VAR=`echo ${VAR}  | /bin/busybox tr [:lower:] [:upper:] 2>/dev/null | /bin/busybox tr ".-" "_" 2>/dev/null`
        #HVAR=${HVAR#*=}
#     ;;
      *=*)
        IVAR=${ARG//=*}
	VAR=`echo ${IVAR}  | /bin/busybox tr [:lower:] [:upper:] 2>/dev/null | /bin/busybox tr ".-" "_" 2>/dev/null`
        HVAR=${ARG#*=}
	# is a first token of tokenized string?  yes:append next tokens until end of string
	case $ARG in 
	  *=\"*)
	    append=true
	    AVAR="${ARGLINE#*=\"}"
	    AVAR="${AVAR//\"*}"
	    ARGLINE=${ARGLINE#*$IVAR=\"$AVAR\"}
	    if [ "$AVAR" = "${HVAR//\"}" ]; then
	      append=""
	    fi
	  ;;
	esac
	case $ARG in 
	  *=\'*)
	    append=true
	    AVAR="${ARGLINE#*=\'}"
	    AVAR="${AVAR//\'*}"
	    ARGLINE=${ARGLINE#*$IVAR=\'$AVAR\'}
	    if [ "$AVAR" = "${HVAR//\'}" ]; then
	      append=""
	    fi
	  ;;
	esac
	case $HVAR in 
	  *=\"*)
	    append=true
	    AVAR="${ARGLINE#*=\"}"
	    AVAR="${AVAR//\"*}"
	    HVAR=${HVAR//=*}
	    HVAR="$HVAR=\"$AVAR\""
	    ARGLINE=${ARGLINE#*$IVAR=$HVAR}
	  ;;
	esac
	case $HVAR in 
	  *=\'*)
	    append=true
	    AVAR="${ARGLINE#*=\'}"
	    AVAR="${AVAR//\'*}"
	    HVAR=${HVAR//=*}
	    HVAR="$HVAR=\'$AVAR\'"
	    ARGLINE=${ARGLINE#*$IVAR=$HVAR}
	  ;;
	esac
      ;;
      *)
         if [ "$append" != "true" ]; then
           VAR=`echo $ARG |  /bin/busybox tr [:lower:] [:upper:] 2>/dev/null | /bin/busybox tr ".-" "_" 2>/dev/null`
	   HVAR="$ARG"
	   # evaluate some special cases
	   case $VAR in
	      0|1|2|3|4|5|6|S)
		VAR=RUNLEVEL
		HVAR=$ARG
	      ;;
	      NOSWAP)
		export SWAPDEV=""
	      ;;
	      NORESUME)
		export RESUMEDEV=""
	      ;;
	      DEBUG)
		export DEBUG_IS_ENABLED="debug_is_enabled"
		export EMSG=""
	      ;;
	      QUIET)
		export VERBOSE=""
		export EMSG="2>/dev/null"
	      ;;
	      VERBOSE)
		export VERBOSE=5 
		export QUIET="" 
		export EMSG=""
	      ;;
	      RW|RO)
		export MOUNTMODE="$HVAR"
	      ;;
	      NOWAIT)
		VAR=WAIT
		HVAR=0
		wait=0
		export WAITFORROOT=0 
		export SYSWAIT=0
	      ;;
	      NONET)
		export IP="" ip="" ETH="" WLAN=""
	      ;;
	      TORAM)
		copy2ram=copy2ram
		export COPY2RAM=copy2ram
	      ;;
	   esac
	 else
	   # last token of a tokenized string
	   case $ARG in
	      *\"|*\')
		 append=""
	      ;;
	   esac
           # end skip
	   #HVAR="$HVAR $ARG"
         fi
	 
     ;;
    esac
    if [ "$append" != "true" ]; then
      echo "VAR='$VAR'"    
      #HVAR=$(echo $HVAR | /bin/busybox tr '\"' "\\'")
      echo "HVAR='$HVAR'"
      TOEVAL="$VAR=$HVAR"
      eval   "$TOEVAL"
      export "$VAR"
    fi

  done

  if [ "$RUNLEVEL" = "" ]; then  RUNLEVEL=$DEFRUNLEVEL;  fi

  #if [ "$LOGLEVEL" = "7" ]; then DEBUG=debug; DEBUG_ENABLED=$DEBUG; fi

  # for now default logging level, switched on here


  export RUNLEVEL QUIET VERBOSE
 
  #
}
#
assign_uuidlabel()
{
  local D d
  if [ "$1" = "" ]; then echo ""; return 1; fi
  D=$1
  d=`echo $D | /bin/busybox tr [:upper:] [:lower:] 2>/dev/null`
  case $d in
     label=*)
       D="/dev/disk/by-label/${D#*=}" #`echo $D | /bin/busybox   cut -f2- -d '='  2>/dev/null`"
     ;;
     devname=*)
       D="/dev/disk/by-name/${D#*=}"  #`echo $D | /bin/busybox   cut -f2- -d '='  2>/dev/null`"
     ;;
     drvname=*)
       D="/dev/disk/by-name/${D#*=}" #`echo $D | /bin/busybox   cut -f2- -d '='  2>/dev/null`"
     ;;
     name=*)
       D="/dev/disk/by-name/${D#*=}"  #`echo $D | /bin/busybox   cut -f2- -d '='  2>/dev/null`"
     ;;
     path=*)
       D="/dev/disk/by-path/${D#*=}"  #`echo $D | /bin/busybox   cut -f2- -d '='  2>/dev/null`"
     ;;
     id=*)
       D="/dev/disk/by-id/${D#*=}" #`echo $D | /bin/busybox   cut -f2- -d '='  2>/dev/null`"
     ;;
     uuid=*)
       D="/dev/disk/by-uuid/${D#*=}" #`echo $D | /bin/busybox   cut -f2- -d '='  2>/dev/null`"
     ;;
     partuuid=*)
       D="/dev/disk/by-partuuid/${D#*=}" #`echo $D | /bin/busybox   cut -f2- -d '='  2>/dev/null`"
     ;;
     #$DISKID=*)
     #  D="/dev/disk/by-id/`echo $D | /bin/busybox   cut -f2- -d '='  2>/dev/null`"
     #;;
  esac
  echo $D
  return 0
}
#
assign_init_variables()
{
  
  evaluate_shellvar_aliases

  
  FROM=`assign_uuidlabel $FROM`
  if [ "$BOOTDEV" != "" ]; then
    BOOTDEV=`assign_uuidlabel $BOOTDEV`
  else
    BOOTDEV=$FROM
  fi
  INITRD=`assign_uuidlabel $INITRD`
  
  #ROOTDEV=`assign_uuidlabel $ROOT`

  DATADEV=`assign_uuidlabel $DATA`

  RESUMEDEV=`assign_uuidlabel $RESUME`

  SWAPDEV=`assign_uuidlabel $SWAP`

  if [ "$SGNFILE" = "" ]; then
      SGNFILE=livecd.sgn
  fi

  #CHANGES=`assign_uuidlabel $CHANGES`

  #AUTOCMD=`echo $AUTOEXEC | /bin/busybox   tr "~" " "`

  INITCMD=$INIT
  export FROM BOOTDEV INITRD ROOTDEV DATADEV RESUMEDEV SWAPDEV INITCMD
  
  
}
#
read_distrofiles()
{
  local SYSDISTRO
  if [ "$SUPPORTED_DISTROS" != "" ]; then
      for SYSDISTRO in "$SUPPORTED_DISTROS"; do
        SYSDISTRO="`echo $SYSDISTRO | /bin/busybox tr -d ' ' 2>/dev/null`"
        if [ -e DISTRO_SPECS.$SYSDISTRO ]; then
          . DISTRO_SPECS.$SYSDISTRO
          echoconsole "$0" "Distribution support for '$SYSDISTRO' loaded....."
          if [ -e $SYSDISTRO.vars ]; then
            . $SYSDISTRO.vars
          else
            echoconsole "$0" "No specific variables for '$SYSDISTRO' read..."
          fi
          if [ -e $SYSDISTRO.functions ]; then
            . $SYSDISTRO.functions
          else
            echoconsole "$0" "No specific functions for '$SYSDISTRO' read..."
          fi
        else
          echoconsole "$0" "Distribution '$SYSDISTRO' not supported, "
          echoconsole "$0" "or no special support necessary. Continuing without..."
        fi
      done
      return 0
  else
    echoconsole "$0" "No special distribution support enabled!"
    return 1
  fi
}
#
probe_for_kernelmodule_squashfs()
{
   # probe for a squashfs archive with kernel modules and mount if possible
   
  local FSYS  SIZE
  FSYS=""
  # are the required file systems compiled into kernel or modules already loaded?
  #FSYS="`/bin/busybox grep squashfs /proc/filesystems 2>/dev/null`"
  #if [ "$FSYS" = "" ]; then
  if `is_not_string_in_file "squashfs" "/proc/filesystems" `; then
    echoconsole "$INITPREF" "no squashfs compiled in kernel '$KERNVER'"      
    echoconsole "$INITPREF" "or no kernel module squashfs loaded"      
    echoconsole "$INITPREF" "continuing without kernel modules from a squashfs...."      
    return 3
  fi
   
  if [ "$SQUASHFSEXT" = "" ]; then SQUASHFSEXT="sfs"; fi   
  export SQUASHFSEXT
  assign_kernver_signed_file "/" "$SQUASHFSEXT"
  
  if [ "$KERNVERFILE" != "" ]; then
    KERNELFILE="$KERNVERFILE"
  else
    echoconsole "$INITPREF" "no squashfs file with kernel modules found"      
    echoconsole "$INITPREF" "continuing without modules in a squashfs...."      
    return 4
    #FSYS="`/bin/busybox grep autofs /proc/filesystems 2>/dev/null`"  
  fi
  # prepare for overlaying kernel modules to target system
  if [ "$OVERLAY" != "" ]; then
    echoconsole "$INITPREF" "Preparing for layerfs (aufs, unionfs, overlayfs) use ......"
    MODTMPDIR="$DEFAULT_MODTMPDIR"
    SIZE=0
    if [ "$MODTMPDIR" = "" ]; then MODTMPDIR="/tmp/modtmpfs"; fi
    export MODTMPDIR
    #/bin/busybox mkdir -p  $MODTMPDIR  2>/dev/null
    #SIZE=`/bin/busybox ls -1s $KERNELFILE  2>/dev/null`
    #SIZE=${SIZE%$KERNELFILE}
    # size in bytes
    #SIZE=$(( $SIZE * 1024 ))
    # add 5% of security buffer
    #SIZE=$(( $SIZE + 5 * $SIZE / 100 ))
    #/bin/busybox mount -n -t tmpfs -o size=$SIZE  tmpfs  $MODTMPDIR  2>/dev/null
    #/bin/busybox mv -f $KERNELFILE  $MODTMPDIR/  2>/dev/null
    #assign_kernver_signed_file "$MODTMPDIR" "$SQUASHFSEXT" 
    #KERNELFILE="$KERNVERFILE"
    echoconsole "$INITPREF" "......prepared for layerfs:"
    echoconsole "$INITPREF" "modules file '$KERNELFILE' at '$MODTMPDIR'"
  fi
  export KERNELFILE
  # install modules at standard place
  /bin/busybox mkdir -p /lib 2>/dev/null
  /bin/busybox mkdir -p /lib/modules 2>/dev/null
  /bin/busybox mkdir -p /lib/modules/$KERNVER 2>/dev/null
  /bin/busybox mkdir -p /lib/modules/$KERNVER/kernel 2>/dev/null
  # you definitely need compiled into kernel : 
  # squashfs with compression support, loop device support,  to mount successfully 
  /bin/busybox mount -t squashfs -o loop,ro   $KERNELFILE  /lib/modules/$KERNVER/kernel 2>/dev/null
  RC=$?
  /bin/busybox sync  2>/dev/null
  echoconsole "$INITPREF" "Mounted '$KERNELFILE' with '$RC' "
  LOCAL_DRIVERS=""
  if [ -e /lib/modules/$KERNVER/kernel/drivers ]; then
    echoconsole "$INITPREF" "Directory for kernelmodules found at /lib/modules/$KERNVER/kernel/drivers"
    LOCAL_DRIVERS="yes"
  else
    # TODO:  how to run unsquashfs as standalone in initramfs without lots of libraries and squashfs compiled in 
    unsquashfs "$KERNELFILE" 2>/dev/null
    #RC=$?
    /bin/busybox sync  2>/dev/null
    #/bin/busybox rm  $KERNELFILE  2>/dev/null
    echoconsole "$INITPREF" " unsquashfs '$KERNELFILE' ended with '$RC' "
    if [ -e squashfs-root ]; then
     /bin/busybox mv -f squashfs-root/*  /lib/modules/$KERNVER/kernel/  2>/dev/null
     /bin/busybox rm -Rf squashfs-root  2>/dev/null
    elif [ -e $MODTMPDIR/squashfs-root ]; then
     /bin/busybox mv -f $MODTMPDIR/squashfs-root/*  /lib/modules/$KERNVER/kernel/  2>/dev/null
     /bin/busybox rm -Rf $MODTMPDIR/squashfs-root  2>/dev/null
    else
      echoconsole "$INITPREF" "Failed to extract kernelmodules in '$KERNELFILE' with 'unsquashfs'!"
    fi
  fi
  export LOCAL_DRIVERS
  /bin/busybox sync  2>/dev/null
  if  ! [  -e  /lib/modules/$KERNVER/kernel/drivers ]; then
    echoconsole "$INITPREF" "Failed to install kernelmodules '$KERNELFILES' at /lib/modules/$KERNVER/kernel !"
  fi
 #set +x

}
#
probe_for_kernelmodule_tarball()
{
  local LIBMODFILES LIBMODF
  LIBMODFILES=""
  LIBMODF=""
  # do not overwrite already mounted kernel module file or existent kernel modules
  if [ "`/bin/busybox ls -1 /lib/modules/$KERNVER/kernel  2>/dev/null`" = "" ]; then
    assign_kernver_signed_file "/" "tar.*"
    if [ "$KERNVERFILE" != "" ]; then
      LIBMODF="$KERNVERFILE"
    else
      assign_kernver_signed_file "/" "tar.*" "libmodules"
      if [ "$KERNVERFILE" != "" ]; then
        LIBMODF="$KERNVERFILE"
      fi
    fi
    if [ "$LIBMODF" = "" ]; then
      LIBMDOFILES="libmodules*.tar.*"
      LIBMODFILES=`/bin/busybox ls -1 "$LIBMODFILES"  2>/dev/null`
      LIBMODF="libmodules-$KERNVER.tar.*"
      LIBMODF=`/bin/busybox ls -1 $LIBMODF   2>/dev/null`
    fi
    
  fi
  # make the following scripts for module loading runnable - if we need some drivers..... 
  if [ "$LIBMODF" = "" ]; then
    # more than one and no current kernelversion in: take only the first one
    LIBMODF="$(echo $LIBMODFILES | /bin/busybox tr "\n" " " 2>/dev/null | /bin/busybox cut -f1 -d ' ' 2>/dev/null)"
  fi 
  if [ "$LIBMODF" != "" ]; then
    export LIBMODF
    if [ -e "$LIBMODF" ]; then
      KERNELFILE="$LIBMODF"
      echoconsole  "$INITPREF" "extracting kernel modules from '$LIBMODF' ..."
      /bin/busybox tar -xf  $LIBMODF   2>/dev/null
      RC=$?
      /bin/busybox sync
      # clean up unused kernelmodules for other kernelversions
      #purge_unused_kernelmodules  "" "$INITPREF"    
      [ $RC -eq 0 ] && echoconsole  "$INITPREF" ".....done.  Continuing boot with these modules...."
      [ $RC -ne 0 ] && echoconsole  "$INITPREF" " Error! Extraction ended with '$RC' !"
      if [ -e /lib/modules/$KERNVER/kernel/drivers ]; then
        echoconsole "$INITPREF" "Directory for kernelmodules found at '/lib/modules/$KERNVER/kernel/' "
        export LOCAL_DRIVERS="yes"
      else
        echoconsole "$INITPREF" "Directory for kernelmodules not found! Continuing..."
      fi
    else
      echoconsole  "$INITPREF" " File '$LIBMODF' does not exist ! "
    fi
  else
    echoconsole  "$INITPREF" " No modules extracted, no file '$KERNVERFILE' found  !"
  fi
}

#
is_not_up_blockdevice()
{
   if `is_accessible_blockdevice "$1"`; then
     return 1
   else
     return 0
   fi
}
#
is_not_up_rootdevice()
{
  if `is_accessible_blockdevice "$ROOTDEV"`; then
    return 1
  else
    return 0
  fi
}
#
is_not_up_bootdevice()
{
  if `is_accessible_blockdevice "$BOOTDEV"`; then
    return 1
  else
    return 0
  fi
}
# under construction
wait_for_rootdevice()
{
  local TIMEOUT 
  /bin/busybox sleep 2 
  return 0
}
#
parse_rootdevice_string()
{
  # this function only parses in RAM, no contact to devices!!!!!
  #set -x
  local ROOTVAR
  UUID=""
  LABEL=""
  PARTUUID_ROOT=""
  DISKID=""
  PATHID=""
  DISKUUID=""
  PARTNUM=""
  ROOTVAR="$(echo $ROOT | /bin/busybox tr [:upper:] [:lower:] 2>/dev/null )"
  if [ "$ROOTVAR" != "" ]; then
    case $ROOTVAR in
      # the OpenSuSE forms are most special cases and have to be first......
      /dev/disk/by-*/*)
        # assign UUID/LABEL content
        ROOTDEV=$ROOT
        ROOTVAR=${ROOT#/dev/disk/*/}
        # ROOT=LABEL or ROOT=UUID  
        ROOT=${ROOT#/*/*/*-}
        # remove / and UUID/LABEL content from $ROOT
        ROOT=${ROOT%/*}  # | /bin/busybox cut -f1 -d "/"    2>/dev/null)"
        eval "ROOT=$ROOT=\"$ROOTVAR\""
        export ROOTDEV ROOT
        parse_rootdevice_string
      ;;
      id=*)
        ROOTVAR=${ROOT#id=}
        DISKID=${ROOTVAR%-part*}
        PARTNUM=${ROOTVAR#$DISKID-part}
        #PARTNUM=${PARTNUM#part}
        if [ "$PARTNUM" != "" ]; then
          ROOTDEV="ID=$DISKID-part$PARTNUM"
        else
          ROOTDEV="ID=$DISKID"
        fi
      ;;
      path=*)
        ROOTVAR=${ROOT#path=}
        PATHID=${ROOTVAR%-part*}
        PARTNUM=${ROOTVAR#$PATHID-part}
        #PARTNUM=${PARTNUM#part}
        if [ "$PARTNUM" != "" ]; then
          ROOTDEV="PATH=$PATHID-part$PARTNUM"
        else
          ROOTDEV="PATH=$PATHID"
        fi
      ;;
    # any information for root device specified in fields with separator ':'?
      *:*:*)
        ROOT=${ROOT%:*}
        ROOTFS=${ROOTVAR%:*}
        ROOTFS=${ROOTVAR#$ROOTFS:}
        export ROOT ROOTFS
        parse_rootdevice_string
      ;;
      *:*)
        ROOT=${ROOT//:*}
        ROOTFSTYPE=${ROOTVAR#*:}
        export ROOT ROOTFSTYPE
        parse_rootdevice_string
      ;;
      # the Slackware, Puppylinux, .... cases
      /dev/hd*|/dev/sd*|/dev/sr*|/dev/mmcblk*|/dev/cdrom*|/dev/dvdrom*|/dev/cdram*|/dev/dvdram*|/dev/scd*)
        ROOTDEV=${ROOTVAR}
        PARTNUM=`last_digits_of_string "$ROOTDEV"` 
        #$(echo $ROOTDEV | /bin/busybox tr -d [:alpha:] 2>/dev/null)
      ;;
      hd*|sd*|sr*|mmcblk*|scd*|cdrom*|dvdrom*|cdram*|dvdram*)
        ROOTDEV="/dev/${ROOTVAR}"
        PARTNUM=`last_digits_of_string "$ROOTDEV"` 
        #$(echo $ROOTDEV | /bin/busybox tr -d [:alpha:] 2>/dev/null)
      ;;
      /dev/*)
        ROOTDEV=$(/bin/busybox readlink -f "${ROOTVAR}" 2>/dev/null)
        PARTNUM=`last_digits_of_string "$ROOTDEV"` 
        #$(echo $ROOTDEV | /bin/busybox tr -d [:alpha:] 2>/dev/null)
      ;;
      # the Redhat, Ubuntu,..., and generic cases
      label=*=uuid=*)
        LABEL=${ROOT#*=}
        #LABEL=${LABEL//=*} # 
        UUID=${LABEL#*=*=}   #  "$(echo $ROOT | /bin/busybox cut -f3  -d "="    2>/dev/null)"
        LABEL=${LABEL//=*}    # "$(echo $LABEL| /bin/busybox cut -f2  -d "="    2>/dev/null)"
        ROOTDEV="UUID=$UUID"
      ;;
      label=*,uuid=*)
        #LABEL="$(echo $ROOT | /bin/busybox cut -f2  -d "="    2>/dev/null| /bin/busybox cut -f1  -d ","    2>/dev/null)"
        #UUID="$(echo $ROOT  | /bin/busybox cut -f2-  -d ","    2>/dev/null | /bin/busybox cut -f1  -d "="    2>/dev/null)"
        UUID=${ROOT#*=*,*=}
        LABEL=${ROOT//,*}
        LABEL=${LABEL#*=}
        ROOTDEV="UUID=$UUID"
      ;;
      uuid=*=label=*)
        UUID=${ROOT#*=}
        LABEL=${UUID#*=*=}
        UUID=${UUID//=*}
        ROOTDEV="UUID=$UUID"
      ;;
      uuid=*,label=*)
        LABEL=${ROOT#uuid=*,label=}
        UUID=${ROOT//,*}
        UUID=${UUID#uuid=}
        ROOTDEV="UUID=$UUID"
      ;;
      label=*)
         LABEL=${ROOT#*=} 
         ROOTDEV="LABEL=\"$LABEL\""
      ;;
      uuid=*)
         UUID=${ROOT#*=}
         ROOTDEV="UUID=$UUID"
      ;;
      partuuid=*)
        PARTUUID=${ROOT#*=}
        # cut out the characters after last "-" in string  
        UUID=${PARTUUID//*-}
        DISKUUID=${PARTUUID//-*}
        # allow maximal 0x16 (=22 decimal) partititons for PARTUUID, else switch to UUID interpretation
        if [ $(( 0x$UUID )) -ge 1 -a $(( 0x$UUID )) -le 22 ]; then  
          PARTNUM=$(( $UUID )) 
        else
          UUID=$PARTUUID
          PARTNUM=""
        fi
        ROOTDEV="PARTUUID=$PARTUUID"
        export PARTUUID_ROOT=$PARTUUID
      ;;
      # is there a shell variable specified before rootdevice's label or uuid declaration?
      *=label=*|*=uuid=*|*=partuuid=*)
        # assign the variable before the uuid/label spec and reparse
        ROOTVAR="$(echo ${ROOT//=*} | /bin/busybox tr [:lower:]  [:upper:]  2>/dev/null | /bin/busybox tr ".-" "_"  2>/dev/null)"
        ROOT=${ROOT#*=}
        eval "$ROOTVAR=\"$ROOT\"" 
        export $ROOTVAR
        if [ "$ROOT" != "" ]; then
          export ROOT
          parse_rootdevice_string
        fi
      ;;
      ask|i|interactive)
        ROOTDEV="ask"
        check_dialog_equipment
        branch_2dialog        
      ;;
    esac

    
  else
      ROOTDEV="ask"
      check_dialog_equipment
      branch_2dialog        
  fi
  export  ROOTDEV LABEL UUID PARTUUID  DISKID PATHID DISKUUID PARTNUM
}
#
#
# under construction
check_dialog_equipment()
{
  return 0
}
#
# under construction
branch2_dialog()
{
  return 0
}
#
echoconsole "[ initsys-functions ]:" "read in!"    
#

